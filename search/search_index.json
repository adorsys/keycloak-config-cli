{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Table of Contents","text":"<ul> <li>Config Files</li> <li>Variable Substitution</li> <li>OTP Policy Configuration</li> <li>Partial Imports</li> <li>Client Roles Management</li> <li>Fine-Grained Admin Permissions V2 </li> <li>User Profile Unmanaged Attributes</li> <li>Logging</li> <li>Non-Master Realm Authentication</li> <li>Supported Features</li> <li>Compatibility with Keycloak</li> <li>Build this Project</li> <li>Run Integration Tests</li> <li>Run this Project</li> <li>Docker</li> <li>Helm</li> <li>Configuration</li> <li>Perform Release</li> <li>Commercial Support</li> </ul>"},{"location":"#keycloak-config-cli","title":"keycloak-config-cli","text":"<p>keycloak-config-cli is a Keycloak utility to ensure the desired configuration state for a realm based on a JSON/YAML file. The format of the JSON/YAML file based on the export realm format. Store and handle the configuration files inside git just like normal code. A Keycloak restart isn't required to apply the configuration.</p>"},{"location":"#config-files","title":"Config files","text":"<p>The config files are based on the keycloak export files. You can use them to re-import your settings. But keep your files as small as possible. Remove all UUIDs and all stuff which is default set by keycloak.</p> <p>moped.json is a full working example file you can consider. Other examples are located in the test resources.</p>"},{"location":"#variable-substitution","title":"Variable Substitution","text":"<p>keycloak-config-cli supports variable substitution of config files. This could be enabled by <code>import.var-substitution.enabled=true</code> (disabled by default).</p> <p>Variables exposed by spring boot (through configtree or external configuration) can be accessed by <code>$(property.name)</code>.</p> <p>In additional, the string substitution support multiple prefixes for different approaches</p> <pre><code>Base64 Decoder:        $(base64Decoder:SGVsbG9Xb3JsZCE=)\nBase64 Encoder:        $(base64Encoder:HelloWorld!)\nJava Constant:         $(const:java.awt.event.KeyEvent.VK_ESCAPE)\nDate:                  $(date:yyyy-MM-dd)\nDNS:                   $(dns:address|apache.org)\nEnvironment Variable:  $(env:USERNAME)\nFile Content:          $(file:UTF-8:src/test/resources/document.properties)\nJava:                  $(java:version)\nLocalhost:             $(localhost:canonical-name)\nProperties File:       $(properties:src/test/resources/document.properties::mykey)\nResource Bundle:       $(resourceBundle:org.example.testResourceBundleLookup:mykey)\nScript:                $(script:javascript:3 + 4)\nSystem Property:       $(sys:user.dir)\nURL Decoder:           $(urlDecoder:Hello%20World%21)\nURL Encoder:           $(urlEncoder:Hello World!)\nURL Content (HTTP):    $(url:UTF-8:http://www.apache.org)\nURL Content (HTTPS):   $(url:UTF-8:https://www.apache.org)\nURL Content (File):    $(url:UTF-8:file:///$(sys:user.dir)/src/test/resources/document.properties)\nXML XPath:             $(xml:src/test/resources/document.xml:/root/path/to/node)\n</code></pre> <p>to replace the values with java system properties or environment variables. Recursive variable replacement like <code>$(file:UTF-8:$(env:KEYCLOAK_PASSWORD_FILE))</code> is enabled by default if <code>import.var-substitution.enabled</code> is set to <code>true</code>.</p> <p>The variable substitution is running before the json parser gets executed. This allows json structures or complex values.</p> <p>See Apache Common <code>StringSubstitutor</code> documentation for more information and advanced usage.</p> <p>Note: Since variable substitution is a part of the keycloak-config-cli, it's done locally. This means, the environment variables need to be available where keycloak-config-cli is executed.</p> <p>If <code>import.var-substitution.prefix=${</code> and <code>import.var-substitution.suffix=}</code> (default in keycloak-config-cli 3.x) is set, then keycloak builtin variables like <code>${role_uma_authorization}</code> needs to be escaped by <code>$${role_uma_authorization}</code>.</p>"},{"location":"#logging","title":"Logging","text":""},{"location":"#json-logging-support","title":"JSON logging support","text":"<p>keycloak-config-cli supports logging in JSON format. To enable, set <code>SPRING_PROFILES_ACTIVE=json-log</code>.</p>"},{"location":"#log-level","title":"Log level","text":"CLI Option ENV Variable Description Default --logging.level.root LOGGING_LEVEL_ROOT define the root log level <code>info</code> --logging.level.keycloak-config-cli LOGGING_LEVEL_KEYCLOAKCONFIGCLI log level of keycloak-config-cli components value of <code>logging.level.root</code> --logging.level.http LOGGING_LEVEL_HTTP log level http requests between keycloak-config-cli and Keycloak value of <code>logging.level.root</code> --logging.level.realm-config LOGGING_LEVEL_REALMCONFIG if set to trace, the realm config including sensitive information will be logged value of <code>logging.level.root</code>"},{"location":"#supported-features","title":"Supported features","text":"<p>See: docs/FEATURES.md</p>"},{"location":"#compatibility-with-keycloak","title":"Compatibility with keycloak","text":"<p>Since keycloak-config-cli 4.0 will support the latest 4 releases of keycloak, if possible. There are some exceptions:</p> <ul> <li>keycloak-config-cli will try the keep an extended support for RH-SSO</li> <li>keycloak-config-cli will cut the support if keycloak introduces some breaking changes</li> </ul>"},{"location":"#build-this-project","title":"Build this project","text":"<p>keycloak-config-cli using maven to build and test keycloak-config-cli. In case maven is not installed on your system, the <code>mvnw</code> command will download maven for you.</p> <p>Further development requirements - Java Development Kit (JDK) - Docker Desktop or an alternative replacement (e.g Rancher Desktop)</p> <p>Before running <code>mvn verify</code>, you have to set the <code>JAVA_HOME</code> environment variable to prevent some test failures.</p> <p>If your are working with a Docker Desktop replacement, some of the Integrationtests can fail due to internal DNS Lookups (host.docker.internal is not reachable). In this case the host can be replaced by a property.</p> <pre><code>mvn verify -DJUNIT_LDAP_HOST=an.alternate.host.or.ip\n</code></pre>"},{"location":"#run-integration-tests-against-real-keycloak","title":"Run integration tests against real keycloak","text":"<p>We are using TestContainers in our integration tests. To run the integration tests a configured docker environment is required.</p> <pre><code>./mvnw verify\n\n# Windows only\nmvnw.cmd verify\n</code></pre>"},{"location":"#run-this-project","title":"Run this project","text":"<p>Start a local keycloak on port 8080:</p> <pre><code>docker-compose down --remove-orphans &amp;&amp; docker-compose up keycloak\n</code></pre> <p>before performing following command:</p> <pre><code>java -jar ./target/keycloak-config-cli.jar \\\n    --keycloak.url=http://localhost:8080 \\\n    --keycloak.ssl-verify=true \\\n    --keycloak.user=admin \\\n    --keycloak.password=admin123 \\\n    --import.files.locations=./contrib/example-config/moped.json\n</code></pre>"},{"location":"#docker","title":"Docker","text":"<p>A docker images is available at DockerHub (docker.io/adorsys/keycloak-config-cli) and quay.io (quay.io/adorsys/keycloak-config-cli)</p> <p>Available docker tags</p> Tag Description <code>latest</code> latest available release of keycloak-config-cli which is built against the latest supported Keycloak release. <code>latest-x.y.z</code> latest available release of keycloak-config-cli which is built against the Keycloak version <code>x.y.z</code>. <code>edge</code> latest commit on the main branch and which is built against the latest supported Keycloak release. <code>a.b.c</code> keycloak-config-cli version <code>a.b.c</code> which is built against the latest supported Keycloak release. <code>a.b.c-x.y.z</code> keycloak-config-cli version <code>a.b.c</code> which is built against the Keycloak version <code>x.y.z</code>. <code>maven</code> See below <p>Additionally, the tag <code>maven</code> contains the source code and compile keycloak-config-cli at runtime. This has the advantage to keycloak-config-cli with Keycloak versions, that not official supported., e.g.:</p> <pre><code>docker run --rm -ti -v $PWD:/config/ -eKEYCLOAK_VERSION=23.0.1 -eMAVEN_CLI_OPTS=\"-B -ntp -q\" adorsys/keycloak-config-cli:edge-build\n</code></pre>"},{"location":"#docker-run","title":"Docker run","text":"<p>For docker <code>-e</code> you have to replace dots with underscores.</p> <pre><code>docker run \\\n    -e KEYCLOAK_URL=\"http://&lt;your keycloak host&gt;:8080/\" \\\n    -e KEYCLOAK_USER=\"&lt;keycloak admin username&gt;\" \\\n    -e KEYCLOAK_PASSWORD=\"&lt;keycloak admin password&gt;\" \\\n    -e KEYCLOAK_AVAILABILITYCHECK_ENABLED=true \\\n    -e KEYCLOAK_AVAILABILITYCHECK_TIMEOUT=120s \\\n    -e IMPORT_FILES_LOCATIONS='/config/*' \\\n    -v &lt;your config path&gt;:/config \\\n    adorsys/keycloak-config-cli:latest\n</code></pre>"},{"location":"#docker-build","title":"Docker build","text":"<p>You can build your own docker image by running</p> <pre><code>docker build -t keycloak-config-cli .\n</code></pre>"},{"location":"#helm","title":"Helm","text":"<p>We provide a helm chart here.</p> <p>Since it makes no sense to deploy keycloak-config-cli as standalone application, you could add it as dependency to your chart deployment.</p> <p>Checkout helm docs about chart dependencies!</p>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#cli-option-environment-variables","title":"CLI option / Environment Variables","text":""},{"location":"#keycloak-options","title":"Keycloak options","text":"CLI Option ENV Variable Description Default Docs --keycloak.url <code>KEYCLOAK_URL</code> Keycloak URL including web context. Format: <code>scheme://hostname:port/web-context</code>. - --keycloak.user <code>KEYCLOAK_USER</code> login user name <code>admin</code> --keycloak.password <code>KEYCLOAK_PASSWORD</code> login user password - --keycloak.client-id <code>KEYCLOAK_CLIENTID</code> login clientId <code>admin-cli</code> --keycloak.client-secret <code>KEYCLOAK_CLIENTSECRET</code> login client secret - --keycloak.grant-type <code>KEYCLOAK_GRANTTYPE</code> login grant_type <code>password</code> --keycloak.login-realm <code>KEYCLOAK_LOGINREALM</code> login realm <code>master</code> --keycloak.ssl-verify <code>KEYCLOAK_SSLVERIFY</code> Verify ssl connection to keycloak <code>true</code> --keycloak.http-proxy <code>KEYCLOAK_HTTPPROXY</code> Connect to Keycloak via HTTP Proxy. Format: <code>scheme://hostname:port</code> - --keycloak.connect-timeout <code>KEYCLOAK_CONNECTTIMEOUT</code> Connection timeout <code>10s</code> --keycloak.read-timeout <code>KEYCLOAK_READTIMEOUT</code> Read timeout <code>10s</code> configured as Java Duration --keycloak.availability-check.enabled <code>KEYCLOAK_AVAILABILITYCHECK_ENABLED</code> Wait until Keycloak is available <code>false</code> configured as Java Duration --keycloak.availability-check.timeout <code>KEYCLOAK_AVAILABILITYCHECK_TIMEOUT</code> Wait timeout for keycloak availability check <code>120s</code> --keycloak.skip-server-info <code>KEYCLOAK_SKIPSERVERINFO</code> Skip fetching Keycloak server info. Required for non-master realm authentication. <code>false</code> skip-server-info.md"},{"location":"#import-options","title":"Import options","text":"CLI Option ENV Variable Description Default Docs --import.validate <code>IMPORT_VALIDATE</code> Validate configuration settings <code>false</code> --import.parallel <code>IMPORT_PARALLEL</code> Enable parallel import of certain resources <code>false</code> --import.files.locations <code>IMPORT_FILES_LOCATIONS</code> Location of config files (URL, file path, or Ant-style pattern) - IMPORT.md --import.files.include-hidden-files <code>IMPORT_FILES_INCLUDE_HIDDEN_FILES</code> Includes files that marked as hidden <code>false</code> --import.files.excludes <code>IMPORT_FILES_EXCLUDES</code> Exclude files with Ant-style pattern - --import.cache.enabled <code>IMPORT_CACHE_ENABLED</code> Enable caching of import file locations <code>true</code> --import.cache.key <code>IMPORT_CACHE_KEY</code> Cache key for importing config. <code>default</code> --import.remote-state.enabled <code>IMPORT_REMOTESTATE_ENABLED</code> Enable remote state management. Purge only resources managed by keycloak-config-cli. <code>true</code> MANAGED.md --import.remote-state.encryption-key <code>IMPORT_REMOTESTATE_ENCRYPTIONKEY</code> Enables remote state in encrypted format. If unset, state will be stored in plain - --import.var-substitution.enabled <code>IMPORT_VARSUBSTITUTION_ENABLED</code> Enable variable substitution config files <code>false</code> --import.var-substitution.nested <code>IMPORT_VARSUBSTITUTION_NESTED</code> Expand variables in variables. <code>true</code> --import.var-substitution.undefined-is-error <code>IMPORT_VARSUBSTITUTION_UNDEFINEDISTERROR</code> Raise exceptions, if variables are not defined. <code>true</code> --import.var-substitution.prefix <code>IMPORT_VARSUBSTITUTION_PREFIX</code> Configure the variable prefix, if <code>import.var-substitution.enabled</code> is <code>true</code>. <code>$(</code> --import.var-substitution.suffix <code>IMPORT_VARSUBSTITUTION_SUFFIX</code> Configure the variable suffix, if <code>import.var-substitution.enabled</code> is <code>true</code>. <code>)</code> --import.behaviors.sync-user-federation <code>IMPORT_BEHAVIORS_SYNC_USER_FEDERATION</code> Enable the synchronization of user federation. <code>false</code> --import.behaviors.remove-default-role-from-user <code>IMPORT_BEHAVIORS_REMOVEDEFAULTROLEFROMUSER</code> The default setting of this flag prevents keycloak-config-cli from removing <code>default-roles-$REALM</code>, even if its not defined in the import json. To make keycloak-config-cli able to remove the <code>default-role-$REALM</code>, <code>import.remove-default-role-from-user</code> must be set to true. In conclusion, you have to add the <code>default-role-$REALM</code> to the realm import on certain users, if you want not remove the <code>default-role-$REALM</code>. <code>false</code> --import.behaviors.skip-attributes-for-federated-user <code>IMPORT_BEHAVIORS_SKIP_ATTRIBUTESFORFEDERATEDUSER</code> Set attributes to null for federated users to avoid read only conflicts <code>false</code> --import.behaviors.checksum-with-cache-key <code>IMPORT_BEHAVIORS_CHECKSUM_WITH_CACHE_KEY</code> Use cache key to store the checksum, if set to <code>false</code> a checksum for each import file is stored <code>true</code> --import.behaviors.checksum-changed <code>IMPORT_BEHAVIORS_CHECKSUM_CHANGED</code> Defines the behavior if the checksum of an imported file has changed. Set to <code>fail</code> when import should be aborted, <code>continue</code> reimport and update the checksum. <code>continue</code>"},{"location":"#spring-boot-options","title":"Spring boot options","text":"CLI Option ENV Variable Description Default Docs --spring.profiles.active <code>SPRING_PROFILES_ACTIVE</code> enable spring profiles. comma separated <code>-</code> Set the Active Spring Profiles --spring.config.import <code>SPRING_CONFIG_IMPORT</code> See below <code>info</code> Configure properties values through files --logging.level.root <code>LOGGING_LEVEL_ROOT</code> define the root log level <code>info</code> Logging --debug <code>DEBUG</code> enables debug mode of spring boot <code>false</code> <p>See application.properties for all available settings.</p> <p>For docker <code>-e</code> you have to remove hyphens and replace dots with underscores.</p> <p>Take a look at spring relax binding or binding from Environment Variables if you need alternative spellings.</p>"},{"location":"#configure-properties-values-through-files","title":"Configure properties values through files","text":"<p>By define an environment variable <code>SPRING_CONFIG_IMPORT=configtree:/run/secrets/</code>, the values of properties can be provided via files instead of plain environment variable values.</p> <p>Example: To configure the property <code>keycloak.password</code> in this case, the file should be in <code>/run/secrets/keycloak.password</code>.</p> <p>The configuration and secret support in Docker Swarm is a perfect match for this use case.</p> <p>Checkout the spring docs to get more information about the configuration trees feature in spring boot.</p>"},{"location":"#perform-release","title":"Perform release","text":"<p>Building releases requires gpg signing.</p> <p>Example to create and add a key to yout git config on MacOS</p> <pre><code>brew install gnupg\ngpg --version\ngpg --full-generate-key\n# follow instructions\ngpg --list-keys\ngpg --list-secret-keys --keyid-format=short\n# check the 8 digit code eg \"ssb   xxxxxxx/E51442F5 2022-01-01 [X]\"\ngit config --global user.signingkey E51442F5\n</code></pre> <p>Finally add the key to your Github account under Settings -&gt; SSH and GPG keys -&gt; New GPG key</p> <p>Create release via maven release plugin:</p> <p><code>shell script ./mvnw -Dresume=false release:prepare release:clean git push --follow-tags</code></p>"},{"location":"#commercial-support","title":"Commercial support","text":"<p>Checkout here for commercial support.</p>"},{"location":"ORGANIZATIONS/","title":"Organizations Feature","text":"<p>Keycloak organizations allow you to manage multi-tenant scenarios by grouping users, identity providers, and domains under organizational units. This feature is available in Keycloak 26+ and requires the <code>organization</code> feature to be enabled.</p>"},{"location":"ORGANIZATIONS/#prerequisites","title":"Prerequisites","text":""},{"location":"ORGANIZATIONS/#keycloak-version","title":"Keycloak Version","text":"<ul> <li>Minimum Keycloak version: 26.0.0</li> <li>Feature flag: <code>organization</code> must be enabled</li> </ul>"},{"location":"ORGANIZATIONS/#enable-organizations-in-keycloak","title":"Enable Organizations in Keycloak","text":""},{"location":"ORGANIZATIONS/#option-1-dockercontainer","title":"Option 1: Docker/Container","text":"<pre><code>docker run -p 8080:8080 \\\n  -e KC_BOOTSTRAP_ADMIN_USERNAME=admin \\\n  -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin123 \\\n  quay.io/keycloak/keycloak:26.5.2 \\\n  start-dev --features=organization\n</code></pre>"},{"location":"ORGANIZATIONS/#option-2-docker-compose","title":"Option 2: Docker Compose","text":"<pre><code>version: '3'\nservices:\n  keycloak:\n    image: quay.io/keycloak/keycloak:26.5.2\n    ports:\n      - \"8080:8080\"\n    environment:\n      KC_BOOTSTRAP_ADMIN_USERNAME: admin\n      KC_BOOTSTRAP_ADMIN_PASSWORD: admin123\n    command: start-dev --features=organization\n</code></pre>"},{"location":"ORGANIZATIONS/#supported-features","title":"Supported Features","text":"Feature Description Since Create organizations Create new organizations with name, alias, and attributes 6.4.1 Update organizations Modify organization properties and attributes 6.4.1 Delete organizations Remove organizations from realm 6.4.1 Manage domains Add/remove verified domains to organizations 6.4.1 Link identity providers Associate realm IdPs with organizations 6.4.1 Manage members Add/remove users as organization members 6.4.1"},{"location":"ORGANIZATIONS/#configuration-format","title":"Configuration Format","text":""},{"location":"ORGANIZATIONS/#basic-organization-structure","title":"Basic Organization Structure","text":"<pre><code>{\n  \"realm\": \"org-feature-test\",\n  \"organizationsEnabled\": true,\n  \"organizations\": [\n    {\n      \"name\": \"Acme Corporation\",\n      \"alias\": \"acme\",\n      \"redirectUrl\": \"https://acme.com/redirect\",\n      \"description\": \"Main organization for Acme Corporation\",\n      \"domains\": [\n        {\n          \"name\": \"acme.com\",\n          \"verified\": false\n        },\n        {\n          \"name\": \"acme.org\", \n          \"verified\": true\n        }\n      ],\n      \"attributes\": {\n        \"industry\": [\"Technology\"],\n        \"location\": [\"San Francisco\"],\n        \"employeeCount\": [\"1000+\"]\n      },\n      \"members\": [\n        {\n          \"username\": \"myuser\"\n        },\n        {\n          \"username\": \"myclientuser\"\n        }\n      ],\n      \"enabled\": true\n    },\n    {\n      \"name\": \"Tech Startup\",\n      \"alias\": \"tech-startup\",\n      \"redirectUrl\": \"https://tech-startup.io/redirect\",\n      \"description\": \"Innovative tech startup\",\n      \"domains\": [\n        {\n          \"name\": \"tech-startup.io\",\n          \"verified\": false\n        }\n      ],\n      \"attributes\": {\n        \"industry\": [\"Software\"],\n        \"stage\": [\"Series A\"],\n        \"funding\": [\"$5M\"]\n      },\n      \"enabled\": true,\n      \"members\": [\n        {\n          \"username\": \"ceo@tech-startup.io\"\n        },\n        {\n          \"username\": \"cto@tech-startup.io\"\n        }\n      ]\n    }\n  ],\n  \"users\": [\n    {\n      \"username\": \"ceo@tech-startup.io\",\n      \"email\": \"ceo@tech-startup.io\",\n      \"enabled\": true,\n      \"firstName\": \"CEO\",\n      \"lastName\": \"TechStartup\"\n    },\n    {\n      \"username\": \"cto@tech-startup.io\",\n      \"email\": \"cto@tech-startup.io\",\n      \"enabled\": true,\n      \"firstName\": \"CTO\",\n      \"lastName\": \"TechStartup\"\n    },\n    {\n      \"username\": \"myuser\",\n      \"email\": \"myuser@mail.de\",\n      \"enabled\": true,\n      \"firstName\": \"My firstname\",\n      \"lastName\": \"My lastname\",\n      \"attributes\": {\n        \"locale\": [\n          \"de\"\n        ]\n      }\n    },\n    {\n      \"username\": \"myclientuser\",\n      \"email\": \"myclientuser@mail.de\",\n      \"enabled\": true,\n      \"firstName\": \"My clientuser's firstname\",\n      \"lastName\": \"My clientuser's lastname\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"myclientuser123\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"ORGANIZATIONS/#complete-example-with-realm-level-identity-providers","title":"Complete Example with Realm-Level Identity Providers","text":"<pre><code>{\n  \"realm\": \"org-feature-test\",\n  \"enabled\": true,\n  \"identityProviders\": [\n    {\n      \"alias\": \"google\",\n      \"providerId\": \"google\",\n      \"enabled\": true,\n      \"config\": {\n        \"clientId\": \"your-google-client-id\",\n        \"clientSecret\": \"your-google-client-secret\",\n        \"hostedDomain\": \"acme.com\"\n      }\n    },\n    {\n      \"alias\": \"github\",\n      \"providerId\": \"github\",\n      \"enabled\": true,\n      \"config\": {\n        \"clientId\": \"your-github-client-id\",\n        \"clientSecret\": \"your-github-client-secret\"\n      }\n    }\n  ],\n  \"organizations\": [\n    {\n      \"name\": \"Acme Corporation\",\n      \"alias\": \"acme\",\n      \"enabled\": true,\n      \"domains\": [\n        {\n          \"name\": \"acme.com\",\n          \"verified\": true\n        }\n      ],\n      \"identityProviders\": [\n        {\n          \"alias\": \"google\"\n        }\n      ],\n      \"members\": [\n        {\n          \"username\": \"myuser\"\n        },\n        {\n          \"username\": \"myclientuser\"\n        }\n      ]\n    },\n    {\n      \"name\": \"Tech Startup\",\n      \"alias\": \"tech-startup\",\n      \"enabled\": true,\n      \"domains\": [\n        {\n          \"name\": \"tech-startup.io\",\n          \"verified\": true\n        }\n      ],\n      \"identityProviders\": [\n        {\n          \"alias\": \"github\"\n        }\n      ],\n      \"members\": [\n        {\n          \"username\": \"ceo@tech-startup.io\"\n        },\n        {\n          \"username\": \"cto@tech-startup.io\"\n        }\n      ]\n    }\n  ],\n  \"users\": [\n    {\n      \"username\": \"myuser\",\n      \"email\": \"myuser@acme.com\",\n      \"enabled\": true,\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"password123\"\n        }\n      ]\n    },\n    {\n      \"username\": \"myclientuser\",\n      \"email\": \"client@acme.com\",\n      \"enabled\": true,\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"password123\"\n        }\n      ]\n    },\n    {\n      \"username\": \"ceo@tech-startup.io\",\n      \"email\": \"ceo@tech-startup.io\",\n      \"enabled\": true,\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"password123\"\n        }\n      ]\n    },\n    {\n      \"username\": \"cto@tech-startup.io\",\n      \"email\": \"cto@tech-startup.io\",\n      \"enabled\": true,\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"password123\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"ORGANIZATIONS/#best-practices","title":"Best Practices","text":""},{"location":"ORGANIZATIONS/#1-identity-provider-order","title":"1. Identity Provider Order","text":"<ul> <li>Define identity providers at the realm level before organizations</li> <li>The CLI automatically handles the correct import order</li> </ul>"},{"location":"ORGANIZATIONS/#2-user-management","title":"2. User Management","text":"<ul> <li>Create users before adding them as organization members</li> <li>Use consistent usernames across the configuration</li> </ul>"},{"location":"ORGANIZATIONS/#3-domain-verification","title":"3. Domain Verification","text":"<ul> <li>Set <code>verified: true</code> only for domains you actually own</li> <li>Use domain verification for security in production</li> </ul>"},{"location":"ORGANIZATIONS/#4-idempotency","title":"4. Idempotency","text":"<ul> <li>The configuration is idempotent - running it multiple times produces the same result</li> <li>Use this for CI/CD pipelines and automated deployments</li> </ul>"},{"location":"RedHat-SSO-compatibility/","title":"RedHat SSO compatibility","text":"<p>In general, RedHat SSO based on Keycloak. In general, keycloak-config-cli is compatible with RedHat SSO.</p> <p>Some specific RH SSO version may differ from keycloak releases which introduce an incompatibility between keycloak-config-cli.</p> <p>While keycloak-config-cli not officially supports RH SSO, it's possible to build keycloak-config-cli against RH SSO.</p>"},{"location":"RedHat-SSO-compatibility/#requirements-installed-on-system","title":"Requirements installed on system","text":"<ul> <li>Java JDK 8+</li> </ul>"},{"location":"RedHat-SSO-compatibility/#steps","title":"Steps","text":""},{"location":"RedHat-SSO-compatibility/#clone-repo","title":"Clone Repo","text":"<pre><code>git clone https://github.com/adorsys/keycloak-config-cli.git\ngit checkout v3.4.0\n</code></pre>"},{"location":"RedHat-SSO-compatibility/#patch-pomxml","title":"Patch pom.xml","text":"<p>This step can be skip if keycloak-config-cli version 4.4.0 or higher is used.</p> <p>Enrich the pom.xml with the changes from: #583</p>"},{"location":"RedHat-SSO-compatibility/#find-correct-release-version-for-keycloak","title":"Find correct release version for keycloak","text":"<p>Identify the internal version of keycloak. Check https://access.redhat.com/articles/2342881</p> <p>Then look at https://mvnrepository.com/artifact/org.keycloak/keycloak-core?repo=redhat-ga to find the correct Keycloak version identifier. For Keycloak 9.0.13, its 9.0.13.redhat-00006.</p>"},{"location":"RedHat-SSO-compatibility/#build","title":"Build","text":"<pre><code>./mvnw clean package -Prh-sso -Dkeycloak.version=9.0.13.redhat-00006\n</code></pre> <p>In case there are compiler errors, then RH introduce breaking changes. But I'm not going to adjust code for such old versions. Sorry.</p>"},{"location":"RedHat-SSO-compatibility/#grab-and-test","title":"Grab and test","text":"<p>In case the build is fine, you build is in <code>target/keycloak-config-cli.jar</code></p>"},{"location":"helm-chart/","title":"Helm Chart","text":""},{"location":"helm-chart/#helm-chart","title":"Helm Chart","text":"<p>The Helm chart for keycloak-config-cli is available via GitHub Pages. To use it,</p> <ol> <li> <p>Add the Helm repository: <pre><code>helm repo add keycloak-config-cli https://adorsys.github.io/keycloak-config-cli/charts\n</code></pre></p> </li> <li> <p>Update your local Helm chart repository cache: <pre><code>helm repo update\n</code></pre></p> </li> <li>Install the chart: <pre><code>helm install keycloak-config-cli keycloak-config-cli/keycloak-config-cli\n</code></pre></li> </ol>"},{"location":"import-settings/","title":"Import settings","text":"<p>The CLI option <code>--import.files.locations</code> support multiple locations of files. In general, all resource location supported by Springs RessourceLoader and PathMatchingResourcePatternResolver are supported. This includes remote locations and zip files as well.</p>"},{"location":"import-settings/#ant-style-path-patterns","title":"Ant-style path patterns.","text":"<p>Part of this mapping code has been kindly borrowed from Apache Ant.</p> <p>The path patten using the following rules:</p> <ul> <li><code>?</code> matches one character</li> <li><code>*</code> matches zero or more characters</li> <li><code>**</code> matches zero or more directories in a path</li> <li><code>{label:regex}</code> matches regex pattern</li> </ul>"},{"location":"import-settings/#examples","title":"Examples","text":"Example Description <code>realm.json</code> realm.json from current work dir <code>path/*.json</code> All files from directory <code>path</code> that ends with <code>.json</code> <code>path/realm_?.json</code> All files from directory <code>path</code> that with name <code>realm_*.json</code>. <code>*</code> can be any single character. <code>path/**/a*.json</code> All files recursively from directory <code>path</code> that begins with <code>a</code> and ends with <code>.json</code> <code>path/{filename:[abc]+}.json</code> All files from directory <code>path</code> that matches regex pattern <code>[abc]+</code>. <code>https://example.com/realm.json</code> Load file from <code>https://example.com/realm.json</code>. <code>https://user:password@example.com/realm.json</code> Load file from <code>https://example.com/realm.json</code> and authenticate with auth basic. Preemptive authentication is not supported. <code>zip:file:path/file.zip!/*</code> All files from zip archive <code>path/file.zip</code> <code>zip:file:path/file.zip!/**/*.yaml</code> All files recursively from zip archive <code>path/file.zip</code> that ends with <code>.yaml</code>"},{"location":"managed-resource/","title":"Full managed resources","text":"<p>keycloak-config-cli manage some types of resources absolutely. For example if a <code>group</code> isn't defined inside the import json but other <code>groups</code> specified, keycloak-config-cli will calculate the difference and delete the <code>group</code> from keycloak.</p> <p>In some cases it is required to include some keycloak defaults because keycloak-config-cli can't detect if the entity comes from a user or auto created by keycloak itself.</p> <p>There are 2 modes to ensure a specific behavior:</p>"},{"location":"managed-resource/#keycloak-should-not-manage-type-of-resources","title":"Keycloak should not manage type of resources:","text":"<p>For example if you don't define any <code>groups</code> inside the import json, keycloak does not touch any <code>groups</code>.</p>"},{"location":"managed-resource/#keycloak-manage-type-of-resources","title":"Keycloak manage type of resources:","text":"<p>For example define any <code>groups</code> you want inside the import json, keycloak ensure that the groups are available but other groups will be deleted. If you define <code>groups</code> but set an empty array, keycloak will delete all groups in keycloak.</p>"},{"location":"managed-resource/#supported-full-managed-resources","title":"Supported full managed resources","text":"Type Additional Information Resource Name Groups - <code>group</code> Required Actions You have to copy the default one to you import json. <code>required-action</code> Client Scopes - <code>client-scope</code> Scope Mappings - <code>scope-mapping</code> Client Scope Mappings - <code>client-scope-mapping</code> Roles - <code>role</code> Components You have to copy the default components to you import json. <code>component</code> Sub Components You have to copy the default components to you import json. <code>sub-component</code> Authentication Flows You have to copy the default components to you import json, expect builtin flows <code>authentication-flow</code> Identity Providers - <code>identity-provider</code> Identity Provider Mappers - <code>identity-provider-mapper</code> Clients - <code>client</code> Clients Authorization Resources The 'Default Resource' is always included. <code>client-authorization-resources</code> Clients Authorization Policies - <code>client-authorization-policies</code> Clients Authorization Scopes - <code>client-authorization-scopes</code> Message Bundles Only message bundles imported with config-cli will be managed/deleted. <code>message-bundles</code>"},{"location":"managed-resource/#disable-deletion-of-managed-entities","title":"Disable deletion of managed entities","text":"<p>If you don't delete properties of a specific type, you can disable this behavior by default a properties like <code>import.managed.&lt;entity&gt;=&lt;full|no-delete&gt;</code>, e.g.: <code>import.managed.required-actions=no-delete</code></p>"},{"location":"managed-resource/#state-management","title":"State management","text":"<p>If <code>import.remote-state.enabled</code> is set to <code>true</code> (default value), keycloak-config-cli will purge only resources they created before by keycloak-config-cli. If <code>import.remote-state.enabled</code> is set to <code>false</code>, keycloak-config-cli will purge all existing entities if they are not defined in import json.</p>"},{"location":"managed-resource/#supported-resources","title":"Supported resources","text":"<p>Following entities does have saved state:</p> <ul> <li>Required Actions</li> <li>Components</li> </ul>"},{"location":"skip-server-info/","title":"Skip Server Info","text":"<p>In modern Keycloak versions (e.g. 26.4.0+), the global <code>/admin/serverinfo</code> endpoint is restricted to users with administrative roles in the <code>master</code> realm.</p> <p>When authenticating against a non-master realm (using <code>--keycloak.login-realm</code>), the authenticated user typically does not have these permissions. This causes the <code>keycloak-config-cli</code> to fail by default as it tries to fetch the server version for compatibility checks.</p>"},{"location":"skip-server-info/#usage","title":"Usage","text":"<p>To authenticate against a non-master realm, you should enable <code>keycloak.skip-server-info=true</code>.</p> <pre><code>java -jar ./target/keycloak-config-cli.jar \\\n    --keycloak.url=http://localhost:8080 \\\n    --keycloak.login-realm=my-realm \\\n    --keycloak.user=my-user \\\n    --keycloak.password=my-password \\\n    --keycloak.skip-server-info=true \\\n    --import.files.locations=...\n</code></pre>"},{"location":"skip-server-info/#consequences","title":"Consequences","text":"<p>When <code>keycloak.skip-server-info</code> is enabled:</p> <ol> <li>Version Fetching is skipped: <code>keycloak-config-cli</code> will not attempt to call <code>/admin/serverinfo</code>.</li> <li>Version Fallback: The tool defaults to version <code>unknown</code> unless <code>--keycloak.version</code> (or <code>KEYCLOAK_VERSION</code>) is explicitly provided.</li> <li>Alternative Health Check: An alternative health check (authenticating against the login realm) is performed to verify Keycloak connectivity.</li> <li>Implicit Compatibility: Some version-specific compatibility checks might be skipped or behave differently. It is recommended to provide the explicit version via <code>--keycloak.version</code> if you know it.</li> </ol>"},{"location":"supported-features/","title":"Supported features","text":"<p>Keycloak Config CLI simplifies managing Keycloak configurations with its extensive feature set. Below is a summary of the functionalities introduced across various versions, enhancing the tool's ability to automate and streamline Keycloak operations:</p> Feature Since Description Create clients 1.0.0 Create client configuration (inclusive protocolMappers) while creating or updating realms Update clients 1.0.0 Update client configuration (inclusive protocolMappers) while updating realms Manage fine-grained authorization of clients 2.2.0 Add and remove fine-grained authorization resources and policies of clients Add roles 1.0.0 Add roles while creating or updating realms Update roles 1.0.0 Update role properties while updating realms Add composites to roles 1.3.0 Add role with realm-level and client-level composite roles while creating or updating realms Add composites to roles 1.3.0 Add realm-level and client-level composite roles to existing role while creating or updating realms Remove composites from roles 1.3.0 Remove realm-level and client-level composite roles from existing role while creating or updating realms Add users 1.0.0 Add users (inclusive password!) while creating or updating realms Add users with roles 1.0.0 Add users with realm-level and client-level roles while creating or updating realms Update users 1.0.0 Update user properties (inclusive password!) while updating realms Add role to user 1.0.0 Add realm-level and client-level roles to user while updating realm Remove role from user 1.0.0 Remove realm-level or client-level roles from user while updating realm Add groups to user 2.0.0 Add groups to user while updating realm Remove groups from user 2.0.0 Remove groups from user while updating realm Add authentication flows and executions 1.0.0 Add authentication flows and executions while creating or updating realms Update authentication flows and executions 1.0.0 Update authentication flow properties and executions while updating realms Remove authentication flows and executions 2.0.0 Remove existing authentication flow properties and executions while updating realms Update builtin authentication flows and executions 2.0.0 Update builtin authentication flow properties and executions while updating realms Add authentication configs 1.0.0 Add authentication configs while creating or updating realms Update authentication configs 2.0.0 Update authentication configs while updating realms Remove authentication configs 2.0.0 Remove existing authentication configs while updating realms Add components 1.0.0 Add components while creating or updating realms Update components 1.0.0 Update components properties while updating realms Remove components 2.0.0 Remove existing sub-components while creating or updating realms Update sub-components 1.0.0 Add sub-components properties while creating or updating realms Remove sub-components 2.0.0 Remove existing sub-components while creating or updating realms Add groups 1.3.0 Add groups (inclusive subgroups!) to realm while creating or updating realms Update groups 1.3.0 Update existing group properties and attributes while creating or updating realms Remove groups 1.3.0 Remove existing groups while updating realms Add/Remove group attributes 1.3.0 Add or remove group attributes in existing groups while updating realms Add/Remove group roles 1.3.0 Add or remove roles to/from existing groups while updating realms Update/Remove subgroups 1.3.0 Like groups, subgroups may also be added/updated and removed while updating realms Add scope-mappings 1.0.0 Add scope-mappings while creating or updating realms Add roles to scope-mappings 1.0.0 Add roles to existing scope-mappings while updating realms Remove roles from scope-mappings 1.0.0 Remove roles from existing scope-mappings while updating realms Add required-actions 1.0.0 Add required-actions while creating or updating realms Update required-actions 1.0.0 Update properties of existing required-actions while updating realms Remove required-actions 2.0.0 Remove existing required-actions while updating realms Add identity providers 1.2.0 Add identity providers while creating or updating realms Update identity providers 1.2.0 Update identity providers while updating realms (improved with 2.0.0) Remove identity providers 2.0.0 Remove identity providers while updating realms Add identity provider mappers 2.0.0 Add identityProviderMappers while updating realms Update identity provider mappers 2.0.0 Update identityProviderMappers while updating realms Remove identity provider mappers 2.0.0 Remove identityProviderMappers while updating realms Add clientScopes 2.0.0 Add clientScopes (inclusive protocolMappers) while creating or updating realms Update clientScopes 2.0.0 Update existing (inclusive protocolMappers) clientScopes while creating or updating realms Remove clientScopes 2.0.0 Remove existing clientScopes while creating or updating realms Add clientScopeMappings 2.5.0 Add clientScopeMapping while creating or updating realms Update clientScopeMappings 2.5.0 Update existing clientScopeMappings while creating or updating realms Remove clientScopeMappings 2.5.0 Remove existing clientScopeMappings while creating or updating realms Synchronize user federation 3.5.0 Synchronize the user federation defined on the realm configuration Synchronize user profile 5.4.0 Synchronize the user profile configuration defined on the realm configuration Synchronize client-policies 5.6.0 Synchronize the client-policies (clientProfiles and clientPolicies) while updating realms Synchronize message bundles 5.12.0 Synchronize message bundles defined on the realm configuration Create organizations 6.4.1 Create organizations with domains, identity providers, and members while creating or updating realms Update organizations 6.4.1 Update organization properties, domains, identity providers, and members while updating realms Remove organizations 6.4.1 Remove existing organizations while updating realms Add organization domains 6.4.1 Add domains to organizations while creating or updating realms Remove organization domains 6.4.1 Remove domains from organizations while updating realms Link identity providers to organizations 6.4.1 Link realm-level identity providers to organizations while creating or updating realms Unlink identity providers from organizations 6.4.1 Unlink identity providers from organizations while updating realms Add members to organizations 6.4.1 Add users as members to organizations while creating or updating realms Remove members from organizations 6.4.1 Remove users from organizations while updating realms"},{"location":"supported-features/#specificities","title":"Specificities","text":""},{"location":"supported-features/#client-authenticationflowbindingoverrides","title":"Client - authenticationFlowBindingOverrides","text":"<p><code>authenticationFlowBindingOverrides</code> on client is configured by Keycloak like this,</p> <pre><code>{\n  \"authenticationFlowBindingOverrides\": {\n    \"browser\": \"ad7d518c-4129-483a-8351-e1223cb8eead\"\n  }\n}\n</code></pre> <p>In order to be able to configure this in <code>keycloak-config-cli</code>, we use authentication flow alias instead of <code>id</code> (which is not known)</p> <p><code>keycloak-config-cli</code> will automatically resolve the alias reference to its ids.</p> <p>So if you need this, you have to configure it like :</p> <pre><code>{\n  \"authenticationFlowBindingOverrides\": {\n    \"browser\": \"my awesome browser flow\"\n  }\n}\n</code></pre>"},{"location":"supported-features/#user-initial-password","title":"User - initial password","text":"<p>To set an initial password that is only respect while the user is created, the userLabel must be named <code>initial</code>.</p> <pre><code>{\n  \"users\": [\n    {\n      \"username\": \"user\",\n      \"email\": \"user@mail.de\",\n      \"enabled\": true,\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"userLabel\": \"initial\",\n          \"value\": \"start123\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"supported-features/#fine-grained-permissions-for-keycloak-objects","title":"Fine-grained permissions for Keycloak objects","text":"<p>Keycloak supports configuring access to certain resource (such as clients, identity providers, roles and groups) using advanced policies.</p> <p>The resources and policies are configured on the client named <code>realm-management</code>:</p> <pre><code>{\n  \"clients\": [\n    {\n      \"clientId\": \"realm-management\",\n      \"authorizationSettings\": {\n        \"allowRemoteResourceManagement\": false,\n        \"policyEnforcementMode\": \"ENFORCING\",\n        \"resources\": [\n          {\n            \"name\": \"idp.resource.1dcbfbe7-1cee-4d42-8c39-d8ed74b4cf22\",\n            \"type\": \"IdentityProvider\",\n            \"ownerManagedAccess\": false,\n            \"scopes\": [\n              {\n                \"name\": \"token-exchange\"\n              }\n            ]\n          }\n        ],\n        \"policies\": [\n          {\n            \"name\": \"token-exchange.permission.idp.1dcbfbe7-1cee-4d42-8c39-d8ed74b4cf22\",\n            \"type\": \"scope\",\n            \"logic\": \"POSITIVE\",\n            \"decisionStrategy\": \"UNANIMOUS\",\n            \"config\": {\n              \"resources\": \"[\\\"idp.resource.1dcbfbe7-1cee-4d42-8c39-d8ed74b4cf22\\\"]\",\n              \"scopes\": \"[\\\"token-exchange\\\"]\"\n            }\n          }\n        ]\n      }\n    }\n  ],\n  \"identityProviders\": [\n    {\n      \"alias\": \"my-identity-provider\",\n      \"providerId\": \"oidc\",\n      \"enabled\": true\n    }\n  ]\n}\n</code></pre> <p>Both resources and policies are named in such a way that the name contains the UUID of the referenced entity (identity provider in the example). This is problematic, as the UUID is not known.</p> <p>Therefore <code>keycloak-config-cli</code> will automatically resolve the object ids during import, using a special dollar syntax:</p> <p>The following transformations are currently implemented:</p> Resource Permission Resolution strategy <code>client.resource.$client-id</code> <code>&lt;scope&gt;.permission.client.$client-id</code> Find a client by client id <code>idp.resource.$alias</code> <code>&lt;scope&gt;.permission.idp.$alias</code> Find an identity provider by alias <code>role.resource.$Realm Role Name</code> <code>&lt;scope&gt;.permission.$Realm Role Name</code> (Note: No <code>.role.</code>) Find a realm role by name <code>group.resource.$/Full Path/To Group</code> <code>&lt;scope&gt;.permission.group.$/Full Path/To Group</code> Find a group by full path <p>The dollar only marks the name for substitution but is not part of it. It is an import failure when the referenced entity does not exist.</p> <p>The example above should therefore be rewritten as:</p> <pre><code>{\n  \"clients\": [\n    {\n      \"clientId\": \"realm-management\",\n      \"authorizationSettings\": {\n        \"allowRemoteResourceManagement\": false,\n        \"policyEnforcementMode\": \"ENFORCING\",\n        \"resources\": [\n          {\n            \"name\": \"idp.resource.$my-identity-provider\",\n            \"type\": \"IdentityProvider\",\n            \"ownerManagedAccess\": false,\n            \"scopes\": [\n              {\n                \"name\": \"token-exchange\"\n              }\n            ]\n          }\n        ],\n        \"policies\": [\n          {\n            \"name\": \"token-exchange.permission.idp.$my-identity-provider\",\n            \"type\": \"scope\",\n            \"logic\": \"POSITIVE\",\n            \"decisionStrategy\": \"UNANIMOUS\",\n            \"config\": {\n              \"resources\": \"[\\\"idp.resource.$my-identity-provider\\\"]\",\n              \"scopes\": \"[\\\"token-exchange\\\"]\"\n            }\n          }\n        ]\n      }\n    }\n  ],\n  \"identityProviders\": [\n    {\n      \"alias\": \"my-identity-provider\",\n      \"providerId\": \"oidc\",\n      \"enabled\": true\n    }\n  ]\n}\n</code></pre>"},{"location":"config/Authenticator-Configuration/","title":"Authenticator configuration","text":""},{"location":"config/Authenticator-Configuration/#authenticatorconfig","title":"AuthenticatorConfig","text":""},{"location":"config/Authenticator-Configuration/#introduction","title":"Introduction","text":"<p>AuthenticatorConfig is a powerful feature in Keycloak that allows you to customize authentication flows by configuring specific authenticators. This documentation will guide you through using AuthenticatorConfig with the Keycloak Config CLI tool.</p>"},{"location":"config/Authenticator-Configuration/#syntax","title":"Syntax","text":"<p>AuthenticatorConfig is defined within the authenticationFlows section of your Keycloak configuration JSON file. Here's the basic structure: <pre><code>{\n  \"authenticationFlows\": [\n    {\n      \"alias\": \"my-custom-flow\",\n      \"authenticationExecutions\": [\n        {\n          \"authenticator\": \"auth-username-password-form\",\n          \"requirement\": \"REQUIRED\",\n          \"authenticatorConfig\": \"my-custom-config\"\n        }\n      ]\n    }\n  ],\n  \"authenticatorConfig\": [\n    {\n      \"alias\": \"my-custom-config\",\n      \"config\": {\n        \"key1\": \"value1\",\n        \"key2\": \"value2\"\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"config/Authenticator-Configuration/#key-components","title":"Key Components","text":""},{"location":"config/Authenticator-Configuration/#alias","title":"Alias","text":"<p>The alias field is a unique identifier for your AuthenticatorConfig. It's used to reference the configuration from within authentication executions1.</p>"},{"location":"config/Authenticator-Configuration/#config","title":"Config","text":"<p>The config object contains key-value pairs that define the specific settings for your authenticator. The available keys and their meanings depend on the authenticator being configured1.</p>"},{"location":"config/Authenticator-Configuration/#common-use-cases","title":"Common Use Cases","text":"<p>Password Policy Configuration</p> <pre><code>{\n  \"alias\": \"password-policy-config\",\n  \"config\": {\n    \"passwordPolicy\": \"length(8) and upperCase(1) and lowerCase(1) and digits(1)\"\n  }\n}\n\nOTP Policy Configuration\njson\n{\n  \"alias\": \"otp-config\",\n  \"config\": {\n    \"otpType\": \"totp\",\n    \"otpHashAlgorithm\": \"HmacSHA1\",\n    \"otpPolicyDigits\": \"6\",\n    \"otpPolicyPeriod\": \"30\"\n  }\n}\n</code></pre>"},{"location":"config/Authenticator-Configuration/#best-practices","title":"Best Practices","text":"<ul> <li><code>Unique Aliases</code>: Ensure each AuthenticatorConfig has a unique alias to avoid conflicts1.</li> <li><code>Consistent Naming</code>: Use descriptive and consistent naming conventions for your aliases.</li> <li><code>Minimal Configuration</code>: Only include necessary configuration keys to keep your JSON file clean and manageable.</li> <li><code>Version Control</code>: Store your Keycloak configuration files in a version control system for easy tracking of changes7.</li> </ul>"},{"location":"config/Authenticator-Configuration/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues with your AuthenticatorConfig: - Verify that the alias in the authenticatorConfig section matches the one referenced in authenticationExecutions. - Check that the config keys are valid for the specific authenticator you're configuring. - Ensure that the Keycloak Config CLI tool has the necessary permissions to apply the configuration changes. You can click here for more information</p>"},{"location":"config/addind-multiple-post-logout-redirect-uris/","title":"Adding Multiple post.logout.redirect.uris","text":""},{"location":"config/addind-multiple-post-logout-redirect-uris/#adding-multiple-postlogoutredirecturis-in-keycloak-configuration","title":"Adding Multiple <code>post.logout.redirect.uris</code> in Keycloak Configuration.","text":"<p>To correctly import multiple <code>post.logout.redirect.uris</code>, you should use the <code>##</code> separators to concatenate URIs into a single string. Here's a step-by-step guide on how to do this:</p>"},{"location":"config/addind-multiple-post-logout-redirect-uris/#open-the-import-file","title":"Open the Import File.","text":"<p>First, navigate to your JSON configuration file where the realm and clients are defined.</p>"},{"location":"config/addind-multiple-post-logout-redirect-uris/#add-multiple-values-for-postlogoutredirecturis","title":"Add Multiple Values for <code>post.logout.redirect.uris</code>.","text":"<p>In the attributes section where you want to add multiple <code>post.logout.redirect.uris</code>, ensure that you use the <code>##</code> separators. Here\u2019s an example configuration:</p> <p>Here is the syntax:</p> <pre><code>\"attributes\": {\n\"post.logout.redirect.uris\": \"https://app1.example.com/logout##https://app2.example.com/logout##https://app3.example.com/logout\"\n},\n</code></pre> <p>This is a simple json example that can be used to see how it works. <pre><code>{\n  \"realm\": \"your-realm\",\n  \"clients\": [\n    {\n      \"clientId\": \"your-client-id\",\n      \"enabled\": true,\n      \"redirectUris\": [\n        \"https://app1.example.com/callback\",\n        \"https://app2.example.com/callback\",\n        \"https://app3.example.com/callback\"\n      ],\n      \"webOrigins\": [\n        \"https://app1.example.com\",\n        \"https://app2.example.com\",\n        \"https://app3.example.com\"\n      ],\n      \"attributes\": {\n        \"post.logout.redirect.uris\": \"https://app1.example.com/logout##https://app2.example.com/logout##https://app3.example.com/logout\"\n      },\n      \"protocol\": \"openid-connect\",\n      \"publicClient\": false,\n      \"standardFlowEnabled\": true,\n      \"implicitFlowEnabled\": false,\n      \"directAccessGrantsEnabled\": true,\n      \"serviceAccountsEnabled\": false,\n      \"authorizationServicesEnabled\": false,\n      \"fullScopeAllowed\": true\n    }\n  ]\n}\n</code></pre></p> <p>In the above configuration, you specify multiple logout redirect URIs separated by <code>##</code>.</p>"},{"location":"config/addind-multiple-post-logout-redirect-uris/#load-the-configuration","title":"Load the Configuration.","text":"<p>Once your configuration file is updated, load it into your Keycloak instance.</p>"},{"location":"config/addind-multiple-post-logout-redirect-uris/#verify-in-the-keycloak-admin-ui","title":"Verify in the Keycloak Admin UI.","text":"<p> After loading the configuration, check the Keycloak Admin UI to verify that the <code>post.logout.redirect.uris</code> are correctly imported with multiple values. You should see the following URIs:</p> <ul> <li><code>https://app1.example.com/logout</code></li> <li><code>https://app2.example.com/logout</code></li> <li><code>https://app3.example.com/logout</code></li> </ul>"},{"location":"config/addind-multiple-post-logout-redirect-uris/#conclusion","title":"Conclusion","text":"<p>By following the above steps, you can successfully add multiple <code>post.logout.redirect.uris</code> in your Keycloak configuration. This approach ensures that all specified URIs are respected during logout redirection processes.</p>"},{"location":"config/apply-jsonschema-in-intellij/","title":"Adding a JSON Schema Validator in IntelliJ","text":"<p>This guide walks you through the process of adding a JSON Schema validator in IntelliJ to enhance your JSON file validation and auto-completion.</p>"},{"location":"config/apply-jsonschema-in-intellij/#step-1-open-intellij-preferences","title":"Step 1: Open IntelliJ Preferences","text":"<ol> <li>Open IntelliJ.</li> <li>Navigate to File &gt; Settings (or IntelliJ IDEA &gt; Preferences on macOS).</li> </ol>"},{"location":"config/apply-jsonschema-in-intellij/#step-2-navigate-to-json-schema-settings","title":"Step 2: Navigate to JSON Schema Settings","text":"<ol> <li>In the settings menu, search for JSON Schema in the search bar.</li> <li>Click on Languages &amp; Frameworks &gt; Schemas and DTDs &gt; JSON Schema Mappings.</li> </ol>"},{"location":"config/apply-jsonschema-in-intellij/#step-3-add-a-new-json-schema","title":"Step 3: Add a New JSON Schema","text":"<ol> <li>Click the + icon to add a new schema.</li> <li>Choose Schema File and select one of the following options:<ul> <li>From File: If you have a local schema file, navigate to and select it.</li> <li>From URL: If the schema is hosted online, enter the URL.</li> <li>Built-in Schema: Select from IntelliJ's built-in options.</li> </ul> </li> </ol>"},{"location":"config/apply-jsonschema-in-intellij/#step-4-map-the-schema-to-your-files","title":"Step 4: Map the Schema to Your Files","text":"<ol> <li>Under Mapped Patterns, click the + icon.</li> <li>Add the file pattern or directory for which the schema should apply. For example, to apply the schema to all <code>config.json</code> files, add <code>config.json</code> as a pattern.</li> <li>You can also use wildcard patterns like <code>.*\\.(json|yaml|yml|JSON)$</code> or specify a folder like <code>src/config/*.json</code>.</li> </ol>"},{"location":"config/apply-jsonschema-in-intellij/#step-5-validate-and-apply-changes","title":"Step 5: Validate and Apply Changes","text":"<ol> <li>Click OK to save the schema configuration.</li> <li>Open a JSON file to ensure IntelliJ is validating it against the schema. You should see:<ul> <li>Auto-completion suggestions.</li> <li>Error messages for invalid fields or types.</li> </ul> </li> </ol>"},{"location":"config/built-in-client-roles/","title":"Deleting Built-in Client Roles","text":"<p>When working with Keycloak clients, certain built-in roles are automatically created by Keycloak for specific client types. Understanding how keycloak-config-cli handles these built-in roles is important to avoid unexpected behavior during configuration imports.</p> <p>Related issues: #849</p>"},{"location":"config/built-in-client-roles/#the-problem","title":"The Problem","text":"<p>Users often encounter confusion when trying to manage client roles because: - Built-in roles are automatically created by Keycloak and cannot be deleted through standard configuration - Attempting to remove built-in roles from configuration files doesn't delete them from Keycloak - It's unclear which roles are built-in vs. custom - The behavior differs between built-in and custom roles</p>"},{"location":"config/built-in-client-roles/#what-are-built-in-client-roles","title":"What Are Built-in Client Roles?","text":"<p>Built-in client roles are automatically created by Keycloak for certain clients, particularly: - realm-management client: Contains roles like <code>view-users</code>, <code>manage-users</code>, <code>view-clients</code>, <code>manage-clients</code>, etc. - account client: Contains roles like <code>manage-account</code>, <code>view-profile</code> - broker client: Contains roles for identity brokering</p> <p>These roles are protected and cannot be deleted via the Admin API or keycloak-config-cli.</p>"},{"location":"config/built-in-client-roles/#behavior-with-remote-state","title":"Behavior with Remote State","text":"Client Role Type With <code>import.remote-state.enabled=true</code> With <code>import.remote-state.enabled=false</code> Built-in roles Cannot be deleted, remain in Keycloak Can't be deleted, remain in Keycloak Custom roles Deleted if removed from config Replaced with only roles in config"},{"location":"config/built-in-client-roles/#usage","title":"Usage","text":""},{"location":"config/built-in-client-roles/#managing-custom-client-roles-only","title":"Managing Custom Client Roles Only","text":"<p>Scenario: You want to manage only your custom client roles without affecting built-in roles. <pre><code>realm: \"myrealm\"\nclients:\n  - clientId: \"my-app\"\n    enabled: true\n    roles:\n      - name: \"app-admin\"\n        description: \"Application administrator\"\n      - name: \"app-user\"\n        description: \"Application user\"\n      - name: \"app-viewer\"\n        description: \"Read-only application access\"\n</code></pre></p> <p>Result: With <code>import.remote-state.enabled=true</code> (default), keycloak-config-cli: - Creates/updates the three custom roles - Ignores any built-in roles - Only manages roles it created</p>"},{"location":"config/built-in-client-roles/#identifying-built-in-roles","title":"Identifying Built-in Roles","text":"<p>Built-in roles typically have these characteristics: - Created automatically when a client is created - Cannot be deleted through Admin Console or API - Usually found in system clients like <code>realm-management</code>, <code>account</code>, <code>broker</code></p> <p>Common built-in roles in <code>realm-management</code> client: - <code>view-realm</code>, <code>view-users</code>, <code>view-clients</code>, <code>view-events</code> - <code>manage-realm</code>, <code>manage-users</code>, <code>manage-clients</code>, <code>manage-events</code> - <code>create-client</code>, <code>impersonation</code>, <code>query-users</code>, <code>query-clients</code></p>"},{"location":"config/built-in-client-roles/#what-you-cannot-do","title":"What You Cannot Do","text":"<p>Attempting to delete built-in roles (this will NOT work): <pre><code>clients:\n  - clientId: \"realm-management\"\n    roles: []\n</code></pre></p> <p>Result: Built-in roles remain in Keycloak unchanged. keycloak-config-cli cannot delete protected system roles.</p>"},{"location":"config/built-in-client-roles/#how-keycloak-config-cli-handles-client-roles","title":"How keycloak-config-cli Handles Client Roles","text":""},{"location":"config/built-in-client-roles/#with-remote-state-enabled-default","title":"With Remote State Enabled (Default)","text":"<pre><code># Configuration file\nclients:\n  - clientId: \"my-app\"\n    roles:\n      - name: \"custom-role-1\"\n      - name: \"custom-role-2\"\n</code></pre> <p>Behavior: 1. keycloak-config-cli creates/updates <code>custom-role-1</code> and <code>custom-role-2</code> 2. Tracks these roles as \"managed\" by keycloak-config-cli 3. If you later remove <code>custom-role-2</code> from config, it will be deleted from Keycloak 4. Any roles created manually in Keycloak UI remain untouched 5. Built-in roles are never affected</p>"},{"location":"config/built-in-client-roles/#without-remote-state","title":"Without Remote State","text":"<pre><code># Configuration file with import.remote-state.enabled=false\nclients:\n  - clientId: \"my-app\"\n    roles:\n      - name: \"custom-role-1\"\n</code></pre> <p>Behavior: 1. keycloak-config-cli attempts to sync the roles list exactly 2. Custom roles not in the config may be removed 3. Built-in roles still cannot be deleted and remain in Keycloak</p>"},{"location":"config/built-in-client-roles/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"config/built-in-client-roles/#1-expecting-built-in-roles-to-be-deleted","title":"1. Expecting Built-in Roles to Be Deleted","text":"<p>Problem: <pre><code>clients:\n  - clientId: \"realm-management\"\n    roles: []  # Expecting all roles to be deleted\n</code></pre></p> <p>Reality: Built-in roles like <code>view-users</code>, <code>manage-realm</code> remain because they're protected by Keycloak.</p> <p>Solution: Accept that built-in roles cannot be deleted. Only manage custom roles through keycloak-config-cli.</p>"},{"location":"config/built-in-client-roles/#2-not-distinguishing-built-in-from-custom-roles","title":"2. Not Distinguishing Built-in from Custom Roles","text":"<p>Problem: Treating all client roles the same way.</p> <p>Solution:  - Document which roles are custom in your organization - Use naming conventions for custom roles (e.g., <code>custom-*</code>, <code>app-*</code>) - Don't attempt to manage built-in system roles</p>"},{"location":"config/built-in-client-roles/#3-exporting-and-re-importing-with-all-roles","title":"3. Exporting and Re-importing with All Roles","text":"<p>Problem: Exporting a realm that includes built-in roles, then trying to manage them all via config. <pre><code># Exported configuration\nclients:\n  - clientId: \"realm-management\"\n    roles:\n      - name: \"view-users\"      # Built-in\n      - name: \"manage-users\"    # Built-in\n      - name: \"custom-admin\"    # Custom\n</code></pre></p> <p>Solution: When creating configuration files from exports, remove built-in roles from the config. Only include custom roles you want to manage.</p> <p>Recommended approach: <pre><code>clients:\n  - clientId: \"realm-management\"\n    roles:\n      - name: \"custom-admin\"    # Only include custom roles\n</code></pre></p>"},{"location":"config/built-in-client-roles/#best-practices","title":"Best Practices","text":"<ol> <li>Don't Include Built-in Roles in Config: Only manage custom roles through keycloak-config-cli</li> <li>Use Naming Conventions: Prefix custom roles (e.g., <code>app-</code>, <code>custom-</code>) to distinguish them from built-in roles</li> <li>Document Custom Roles: Maintain a list of which roles are custom to your organization</li> <li>Use Remote State: Keep <code>import.remote-state.enabled=true</code> to avoid accidentally affecting manually created roles</li> <li>Separate System Clients: Avoid including system clients like <code>realm-management</code> in your configuration files unless necessary</li> <li>Clean Exported Configs: When using Keycloak exports as a starting point, remove all built-in roles before using as configuration</li> </ol>"},{"location":"config/built-in-client-roles/#configuration-options","title":"Configuration Options","text":"<pre><code># Enable remote state (default) - only manages roles it created\n--import.remote-state.enabled=true\n\n# Validate configuration before import\n--import.validate=true\n</code></pre>"},{"location":"config/built-in-client-roles/#workarounds","title":"Workarounds","text":"<p>If you need to manage permissions typically controlled by built-in roles:</p>"},{"location":"config/built-in-client-roles/#option-1-use-role-composites","title":"Option 1: Use Role Composites","text":"<p>Instead of deleting built-in roles, create custom composite roles that include built-in roles: <pre><code>roles:\n  realm:\n    - name: \"my-admin-role\"\n      description: \"Custom admin role\"\n      composite: true\n      composites:\n        client:\n          realm-management:\n            - \"view-users\"\n            - \"manage-users\"\n</code></pre></p>"},{"location":"config/built-in-client-roles/#option-2-use-fine-grained-admin-permissions","title":"Option 2: Use Fine-Grained Admin Permissions","text":"<p>For Keycloak 26.2+, use fine-grained admin permissions instead of relying on built-in roles. See Keycloak fine-grained permissions documentation.</p>"},{"location":"config/built-in-client-roles/#option-3-manage-through-admin-console","title":"Option 3: Manage Through Admin Console","text":"<p>For built-in roles and system clients, manage permissions directly through Keycloak Admin Console rather than via configuration files.</p>"},{"location":"config/built-in-client-roles/#consequences","title":"Consequences","text":"<p>When working with client roles in keycloak-config-cli:</p> <ol> <li>Built-in Roles Are Protected: System roles in clients like <code>realm-management</code>, <code>account</code>, and <code>broker</code> cannot be deleted programmatically</li> <li>Custom Roles Are Manageable: Roles you create can be fully managed (created, updated, deleted) through configuration files</li> <li>Remote State Recommended: Using remote state tracking prevents accidental deletion of manually created roles</li> <li>Export Cleanup Required: Keycloak exports include built-in roles which should be removed before using as configuration source</li> </ol>"},{"location":"config/built-in-client-roles/#related-issues","title":"Related Issues","text":"<ul> <li>#849 - Deleting built-in client roles</li> <li>#940 - Client roles case sensitivity</li> </ul>"},{"location":"config/built-in-client-roles/#additional-resources","title":"Additional Resources","text":"<ul> <li>Managed Resources Documentation</li> <li>Keycloak Admin API Documentation</li> </ul>"},{"location":"config/environmental-variable-substitution-for-json-array/","title":"Environment Variable Substitution for JSON Arrays","text":""},{"location":"config/environmental-variable-substitution-for-json-array/#environment-variable-substitution-for-json-arrays","title":"Environment Variable Substitution for JSON Arrays","text":"<p>This document provides a step-by-step guide on importing environment variables into JSON arrays using the Keycloak Config CLI.</p>"},{"location":"config/environmental-variable-substitution-for-json-array/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ensure you have dotenv installed and configured in your environment.</li> <li>Have a Keycloak Config CLI setup ready for performing realm imports.</li> </ul>"},{"location":"config/environmental-variable-substitution-for-json-array/#steps-to-perform-import-of-environment-variables","title":"Steps to Perform Import of Environment Variables","text":"<ul> <li> <p>Step 1: Configure the .env File</p> <p>Create or update your .env file to include the necessary environment variables. For example:</p> </li> </ul> <p><pre><code>CLIENT_WEBAPP_REDIRECT_URIS=\"https://app1.example.com/callback\",\"https://app2.example.com/callback\",\"https://app3.example.com/callback\"\n</code></pre> This environment variable contains a comma-separated list of redirect URIs.</p> <ul> <li>Step 2: Prepare the JSON Configuration File</li> </ul> <p>Include the environment variable reference in your JSON configuration file. For example:</p> <p><pre><code>{\n  \"enabled\": true,\n  \"realm\": \"realmWithClient\",\n  \"clients\": [\n    {\n      \"clientId\": \"my-client\",\n      \"redirectUris\": [\"$(env:CLIENT_WEBAPP_REDIRECT_URIS)\"]\n    }\n  ]\n}\n</code></pre> Here, the <code>$(env:CLIENT_WEBAPP_REDIRECT_URIS)</code> syntax indicates that the value should be replaced with the corresponding environment variable.</p> <ul> <li>Step 3: Execute the Import Command</li> </ul> <p>Use the dotenv command together with the import command to load the .env file and execute the Keycloak Config CLI import:</p> <p><pre><code>dotenv -e /PATH/TO/THE/.env kc-cli import --file /PATH/TO/CONFIG.JSON\n</code></pre> Replace /PATH/TO/THE/.env with the full path to your .env file and /PATH/TO/CONFIG.JSON with the path to your JSON configuration file.</p> <ul> <li>Step 4: Enable Variable Substitution</li> </ul> <p>Set the IMPORT_VARSUBSTITUTION_ENABLED environment variable to true to activate variable substitution:</p> <p><pre><code>export IMPORT_VARSUBSTITUTION_ENABLED=true\n</code></pre> Ensure this environment variable is set in your shell or runtime environment before performing the import.</p>"},{"location":"config/fine-grained-admin-permissions-v2/","title":"Fine-Grained Admin Permissions (FGAP) V2","text":"<p>Keycloak 26.2.x introduced Fine-Grained Admin Permissions V2 (FGAP V2), a significant update to the permission model for managing administrative access to Keycloak resources. Understanding the differences between V1 and V2, and how to configure permissions correctly in keycloak-config-cli, is essential for managing realm security in Keycloak 26.2+.</p> <p>Related issues: #1301</p>"},{"location":"config/fine-grained-admin-permissions-v2/#the-problem","title":"The Problem","text":"<p>Users encounter challenges with fine-grained permissions in Keycloak 26.2+ because: - FGAP V2 introduces breaking changes from V1 - The permission model changed from <code>realm-management</code> client to <code>admin-permissions</code> client - Resource and policy configuration syntax is different between versions - Existing V1 configurations don't work with V2 - The <code>admin-permissions</code> client is system-managed and cannot be configured via imports - Authorization settings for <code>admin-permissions</code> are blocked by Keycloak API - Placeholder syntax for referencing resources changed - It's unclear how to migrate from V1 to V2</p>"},{"location":"config/fine-grained-admin-permissions-v2/#what-changed-in-keycloak-262","title":"What Changed in Keycloak 26.2","text":""},{"location":"config/fine-grained-admin-permissions-v2/#fgap-v1-keycloak-262","title":"FGAP V1 (Keycloak &lt; 26.2)","text":"<p>Configuration Location: <code>realm-management</code> client</p> <p>Resource Naming: Used UUIDs in resource/policy names <pre><code>clients:\n  - clientId: \"realm-management\"\n    authorizationSettings:\n      resources:\n        - name: \"client.resource.$my-client-id\"\n          type: \"Client\"\n      policies:\n        - name: \"manage.permission.client.$my-client-id\"\n          type: \"scope\"\n</code></pre></p> <p>Characteristics: - Authorization configured on <code>realm-management</code> client - UUID-based resource naming with <code>$placeholder</code> syntax - Full API access to authorization settings - Can be managed via keycloak-config-cli</p>"},{"location":"config/fine-grained-admin-permissions-v2/#fgap-v2-keycloak-262","title":"FGAP V2 (Keycloak 26.2+)","text":"<p>Configuration Location: <code>admin-permissions</code> client (system-managed)</p> <p>Resource Naming: Uses <code>authorizationSchema</code> with typed resources <pre><code>realm: \"my-realm\"\nadminPermissionsEnabled: true  # Creates admin-permissions client\n\n# admin-permissions client is system-managed\n# Cannot configure authorization settings via import\n</code></pre></p> <p>Characteristics: - Authorization configured on <code>admin-permissions</code> client - Schema-based resource type definitions - Cleaner permission model - API access blocked - cannot import authorization settings - Must manage permissions through Admin Console or dedicated FGAP V2 APIs</p>"},{"location":"config/fine-grained-admin-permissions-v2/#key-differences-v1-vs-v2","title":"Key Differences: V1 vs V2","text":"Aspect FGAP V1 FGAP V2 Client <code>realm-management</code> <code>admin-permissions</code> Keycloak Version &lt; 26.2 26.2+ Configuration Via keycloak-config-cli System-managed, blocked from imports Resource Types Dynamic, UUID-based Schema-defined (Clients, Groups, Users, Roles) Policy Types Generic scope policies Type-specific permissions Resource Naming <code>client.resource.$id</code> Direct reference or schema-based Import Support Full Limited (realm-level only) Management Config files Admin Console or FGAP V2 API"},{"location":"config/fine-grained-admin-permissions-v2/#configuration-in-keycloak-262","title":"Configuration in Keycloak 26.2+","text":""},{"location":"config/fine-grained-admin-permissions-v2/#enable-fgap-v2","title":"Enable FGAP V2","text":"<p>Scenario: Enable fine-grained permissions for a realm. <pre><code>realm: \"my-realm\"\nadminPermissionsEnabled: true  # Enables FGAP V2\nenabled: true\n\n# Do NOT include admin-permissions client configuration\n# It is system-managed by Keycloak\n</code></pre></p> <p>Result: - <code>admin-permissions</code> client is automatically created - FGAP V2 is enabled for the realm - Permissions must be configured through Admin Console</p> <p>Important: Unlike V1, you cannot configure authorization settings for <code>admin-permissions</code> client via config files.</p>"},{"location":"config/fine-grained-admin-permissions-v2/#what-you-can-configure-custom-clients","title":"What You CAN Configure (Custom Clients)","text":"<p>You can still configure full authorization for your own clients (not <code>admin-permissions</code>): <pre><code>realm: \"my-realm\"\nadminPermissionsEnabled: true\n\nclients:\n  - clientId: \"my-custom-app\"\n    enabled: true\n    authorizationServicesEnabled: true\n    authorizationSettings:\n      allowRemoteResourceManagement: true\n      policyEnforcementMode: \"ENFORCING\"\n\n      resources:\n        - name: \"premium-resource\"\n          type: \"urn:my-custom-app:resources:premium\"\n          ownerManagedAccess: false\n          scopes:\n            - name: \"view\"\n            - name: \"edit\"\n            - name: \"delete\"\n\n      policies:\n        - name: \"admin-only-policy\"\n          type: \"role\"\n          logic: \"POSITIVE\"\n          decisionStrategy: \"UNANIMOUS\"\n          config:\n            roles: '[{\"id\":\"admin\",\"required\":true}]'\n\n        - name: \"premium-resource-permission\"\n          type: \"resource\"\n          logic: \"POSITIVE\"\n          decisionStrategy: \"UNANIMOUS\"\n          config:\n            defaultResourceType: \"urn:my-custom-app:resources:premium\"\n            resources: '[\"premium-resource\"]'\n            applyPolicies: '[\"admin-only-policy\"]'\n\nroles:\n  realm:\n    - name: \"admin\"\n      description: \"Administrator role\"\n</code></pre></p> <p>This works because: - It's your custom client, not the system <code>admin-permissions</code> client - Full authorization API access is available for custom clients - Standard FGAP configuration applies</p>"},{"location":"config/fine-grained-admin-permissions-v2/#what-you-cannot-configure","title":"What You CANNOT Configure","text":"<p>This DOES NOT work: <pre><code>realm: \"my-realm\"\nadminPermissionsEnabled: true\n\nclients:\n  - clientId: \"admin-permissions\"  # \u274c System-managed client\n    authorizationSettings:\n      resources:\n        - name: \"client.resource.$my-client\"\n          type: \"Client\"\n      policies:\n        - name: \"manage.permission.client.$my-client\"\n          type: \"scope\"\n          config:\n            resources: '[\"client.resource.$my-client\"]'\n            scopes: '[\"manage\"]'\n</code></pre></p> <p>Why it fails: - <code>admin-permissions</code> client is system-managed - Keycloak blocks standard Authorization Services API calls for this client - Returns <code>400 Bad Request</code> with <code>unknown_error</code> - By design to prevent external modification of the system permission model</p> <p>Error you'll see: <pre><code>Skipping authorization settings for 'admin-permissions' client in realm 'my-realm' - \nFGAP V2 manages this client internally and blocks API access.\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#managing-fgap-v2-permissions","title":"Managing FGAP V2 Permissions","text":"<p>Since you cannot configure <code>admin-permissions</code> via imports, here's how to manage permissions:</p>"},{"location":"config/fine-grained-admin-permissions-v2/#method-1-keycloak-admin-console","title":"Method 1: Keycloak Admin Console","text":"<p>Steps:</p> <ol> <li>Navigate to Realm Settings \u2192 Permissions</li> <li>Enable permissions for resource types:</li> <li>Users</li> <li>Groups  </li> <li>Clients</li> <li> <p>Roles</p> </li> <li> <p>Configure permissions per resource:</p> </li> <li>Go to the specific resource (e.g., Clients \u2192 select client)</li> <li>Click Permissions tab</li> <li>Enable Permissions Enabled</li> <li>Configure who can manage, view, map-roles, etc.</li> </ol> <p>Example: Grant Client Management to a Role</p> <ol> <li>Go to Clients \u2192 select <code>my-app</code> client</li> <li>Click Permissions tab</li> <li>Enable Permissions Enabled</li> <li>Create policy:</li> <li>Name: <code>client-admin-policy</code></li> <li>Type: <code>Role</code></li> <li>Roles: <code>client-admin</code></li> <li>Create permission:</li> <li>Resource: <code>my-app</code></li> <li>Scopes: <code>manage</code>, <code>view</code></li> <li>Policies: <code>client-admin-policy</code></li> </ol>"},{"location":"config/fine-grained-admin-permissions-v2/#method-2-fgap-v2-rest-api-advanced","title":"Method 2: FGAP V2 REST API (Advanced)","text":"<p>Keycloak provides dedicated FGAP V2 REST endpoints (separate from standard Authorization Services API).</p> <p>Enable Permissions for a Client: <pre><code># Enable permissions for a specific client\ncurl -X PUT \"http://localhost:8080/admin/realms/my-realm/clients/{client-uuid}/management/permissions\" \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"enabled\": true\n  }'\n</code></pre></p> <p>Note: These are specialized endpoints for FGAP V2, not the standard <code>/authz/</code> endpoints.</p>"},{"location":"config/fine-grained-admin-permissions-v2/#method-3-terraform-or-infrastructure-as-code","title":"Method 3: Terraform or Infrastructure as Code","text":"<p>Use Terraform Keycloak provider with FGAP V2 resources: <pre><code>resource \"keycloak_realm\" \"my_realm\" {\n  realm = \"my-realm\"\n  admin_permissions_enabled = true\n}\n\nresource \"keycloak_client_permissions\" \"my_app_permissions\" {\n  realm_id = keycloak_realm.my_realm.id\n  client_id = keycloak_openid_client.my_app.id\n\n  enabled = true\n}\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#v2-resource-types-and-scopes","title":"V2 Resource Types and Scopes","text":"<p>FGAP V2 defines four primary resource types, each with specific scopes:</p>"},{"location":"config/fine-grained-admin-permissions-v2/#1-clients","title":"1. Clients","text":"<p>Available Scopes: - <code>view</code> - View client configuration - <code>manage</code> - Full client management - <code>map-roles</code> - Assign roles to client - <code>map-roles-client-scope</code> - Map client scopes - <code>map-roles-composite</code> - Manage composite roles</p> <p>Example Permission: \"Allow <code>client-admin</code> role to manage <code>my-app</code> client\"</p>"},{"location":"config/fine-grained-admin-permissions-v2/#2-groups","title":"2. Groups","text":"<p>Available Scopes: - <code>view</code> - View group - <code>view-members</code> - View group members - <code>manage</code> - Manage group settings - <code>manage-members</code> - Add/remove members - <code>manage-membership</code> - Control membership - <code>impersonate-members</code> - Impersonate group members</p> <p>Example Permission: \"Allow <code>hr-admin</code> role to manage members of <code>/Employees</code> group\"</p>"},{"location":"config/fine-grained-admin-permissions-v2/#3-users","title":"3. Users","text":"<p>Available Scopes: - <code>view</code> - View user profile - <code>manage</code> - Full user management - <code>map-roles</code> - Assign roles to user - <code>manage-group-membership</code> - Manage group membership - <code>impersonate</code> - Impersonate user</p> <p>Example Permission: \"Allow <code>support-team</code> role to view and impersonate users\"</p>"},{"location":"config/fine-grained-admin-permissions-v2/#4-roles","title":"4. Roles","text":"<p>Available Scopes: - <code>map-role</code> - Assign role to users - <code>map-role-client-scope</code> - Map to client scopes - <code>map-role-composite</code> - Use in composite roles</p> <p>Example Permission: \"Allow <code>role-admin</code> role to assign <code>premium-user</code> role\"</p>"},{"location":"config/fine-grained-admin-permissions-v2/#migration-from-v1-to-v2","title":"Migration from V1 to V2","text":""},{"location":"config/fine-grained-admin-permissions-v2/#step-1-identify-current-v1-configuration","title":"Step 1: Identify Current V1 Configuration","text":"<p>Locate V1 configuration in your files: <pre><code># V1 Configuration (Keycloak &lt; 26.2)\nclients:\n  - clientId: \"realm-management\"\n    authorizationSettings:\n      resources:\n        - name: \"client.resource.$my-app\"\n          type: \"Client\"\n        - name: \"idp.resource.$google-idp\"\n          type: \"IdentityProvider\"\n      policies:\n        - name: \"manage.permission.client.$my-app\"\n          type: \"scope\"\n          config:\n            resources: '[\"client.resource.$my-app\"]'\n            scopes: '[\"manage\"]'\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#step-2-remove-v1-configuration-from-config-files","title":"Step 2: Remove V1 Configuration from Config Files","text":"<p>Create migration plan: <pre><code># migration-notes.md\n# V1 Permissions to Migrate:\n# 1. Client: my-app - managed by client-admin role\n# 2. IDP: google-idp - managed by security-team role\n# 3. Group: /Developers - managed by team-lead role\n</code></pre></p> <p>Remove from config files: <pre><code># Remove realm-management authorization settings\n# Keep this commented for reference during migration\n\n# clients:\n#   - clientId: \"realm-management\"\n#     authorizationSettings: ...\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#step-3-update-realm-configuration","title":"Step 3: Update Realm Configuration","text":"<pre><code>realm: \"my-realm\"\nadminPermissionsEnabled: true  # Enable FGAP V2\n\n# Define roles that will be used for permissions\nroles:\n  realm:\n    - name: \"client-admin\"\n      description: \"Can manage specific clients\"\n    - name: \"security-team\"\n      description: \"Can manage identity providers\"\n    - name: \"team-lead\"\n      description: \"Can manage developer group\"\n</code></pre>"},{"location":"config/fine-grained-admin-permissions-v2/#step-4-import-updated-configuration","title":"Step 4: Import Updated Configuration","text":"<pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.user=admin \\\n  --keycloak.password=admin \\\n  --import.files.locations=realm-v2-config.yaml\n</code></pre> <p>Result: - FGAP V2 is enabled - <code>admin-permissions</code> client created - V1 authorization settings removed - Ready for manual permission configuration</p>"},{"location":"config/fine-grained-admin-permissions-v2/#step-5-configure-permissions-manually","title":"Step 5: Configure Permissions Manually","text":"<p>For each resource identified in Step 2:</p> <ol> <li>Client: my-app</li> <li>Admin Console \u2192 Clients \u2192 <code>my-app</code> \u2192 Permissions</li> <li>Enable permissions</li> <li>Create role policy for <code>client-admin</code></li> <li> <p>Create manage permission with <code>manage</code> scope</p> </li> <li> <p>IDP: google-idp</p> </li> <li>Admin Console \u2192 Identity Providers \u2192 <code>google-idp</code> \u2192 Permissions</li> <li>Enable permissions</li> <li>Create role policy for <code>security-team</code></li> <li> <p>Create manage permission</p> </li> <li> <p>Group: /Developers</p> </li> <li>Admin Console \u2192 Groups \u2192 <code>/Developers</code> \u2192 Permissions</li> <li>Enable permissions</li> <li>Create role policy for <code>team-lead</code></li> <li>Create manage-members permission</li> </ol>"},{"location":"config/fine-grained-admin-permissions-v2/#step-6-test-permissions","title":"Step 6: Test Permissions","text":"<p>Verify each role can access appropriate resources: <pre><code># Test as client-admin\n# Should be able to manage my-app client\n\n# Test as security-team\n# Should be able to manage google-idp\n\n# Test as team-lead\n# Should be able to manage /Developers group\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"config/fine-grained-admin-permissions-v2/#1-trying-to-import-admin-permissions-authorization","title":"1. Trying to Import admin-permissions Authorization","text":"<p>Problem: <pre><code>clients:\n  - clientId: \"admin-permissions\"\n    authorizationSettings:\n      resources: [...]  # This won't work\n</code></pre></p> <p>Error: <pre><code>400 Bad Request: unknown_error\n</code></pre></p> <p>Solution: Remove authorization settings for <code>admin-permissions</code> from config files. Use Admin Console instead.</p>"},{"location":"config/fine-grained-admin-permissions-v2/#2-expecting-v1-syntax-to-work","title":"2. Expecting V1 Syntax to Work","text":"<p>Problem: <pre><code># V1 syntax in Keycloak 26.2+\nclients:\n  - clientId: \"realm-management\"\n    authorizationSettings:\n      resources:\n        - name: \"client.resource.$my-client\"\n</code></pre></p> <p>Result: Configuration is ignored or causes warnings.</p> <p>Solution: Remove V1 configuration and migrate to V2 approach.</p>"},{"location":"config/fine-grained-admin-permissions-v2/#3-not-enabling-adminpermissionsenabled","title":"3. Not Enabling adminPermissionsEnabled","text":"<p>Problem: <pre><code>realm: \"my-realm\"\n# Missing: adminPermissionsEnabled: true\n</code></pre></p> <p>Result: FGAP V2 not enabled, permissions cannot be configured.</p> <p>Solution: <pre><code>realm: \"my-realm\"\nadminPermissionsEnabled: true\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#4-confusion-between-custom-client-and-admin-permissions","title":"4. Confusion Between Custom Client and admin-permissions","text":"<p>Problem: Thinking all authorization configuration is blocked.</p> <p>Clarification: - \u2705 Custom client authorization: Fully supported - \u274c <code>admin-permissions</code> client authorization: Blocked</p> <p>You can still do this: <pre><code>clients:\n  - clientId: \"my-custom-app\"  # Your client\n    authorizationSettings:\n      resources: [...]  # This works!\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#5-missing-role-definitions","title":"5. Missing Role Definitions","text":"<p>Problem: Creating permissions for roles that don't exist.</p> <p>Solution: Define roles before configuring permissions: <pre><code>roles:\n  realm:\n    - name: \"client-admin\"\n      description: \"Client administrator\"\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Enable FGAP V2 at Realm Level <pre><code>   realm: \"my-realm\"\n   adminPermissionsEnabled: true\n</code></pre></p> </li> <li> <p>Remove V1 Configuration</p> </li> <li>Clean up old <code>realm-management</code> authorization settings</li> <li> <p>Document migration in comments</p> </li> <li> <p>Define Roles First</p> </li> <li>Create all necessary roles before configuring permissions</li> <li> <p>Use descriptive names and descriptions</p> </li> <li> <p>Document Permissions Externally</p> </li> <li>Since permissions can't be in config files, maintain documentation</li> <li> <p>Use a <code>PERMISSIONS.md</code> file: <pre><code>   # FGAP V2 Permissions\n\n   ## Client: my-app\n   - Role: client-admin\n   - Scopes: manage, view\n\n   ## Group: /Developers\n   - Role: team-lead\n   - Scopes: manage-members\n</code></pre></p> </li> <li> <p>Test Permissions Thoroughly</p> </li> <li>Verify each role has appropriate access</li> <li>Test in dev environment first</li> <li> <p>Document test cases</p> </li> <li> <p>Use Terraform for Infrastructure as Code</p> </li> <li>Consider Terraform for permission management</li> <li>Provides version control for permissions</li> <li> <p>Enables reproducible deployments</p> </li> <li> <p>Regular Audits</p> </li> <li>Review permissions periodically</li> <li>Remove unused permissions</li> <li> <p>Verify principle of least privilege</p> </li> <li> <p>Separate Custom Client Authorization</p> </li> <li>Use custom clients for application-specific authorization</li> <li>Don't mix with FGAP V2 admin permissions</li> <li>Keep concerns separated</li> </ol>"},{"location":"config/fine-grained-admin-permissions-v2/#troubleshooting","title":"Troubleshooting","text":""},{"location":"config/fine-grained-admin-permissions-v2/#permissions-not-working-after-migration","title":"Permissions Not Working After Migration","text":"<p>Symptom: Users who had permissions in V1 no longer have access in V2</p> <p>Cause: V2 permissions not configured after migration</p> <p>Solution: 1. Verify <code>adminPermissionsEnabled: true</code> in realm 2. Check <code>admin-permissions</code> client exists 3. Manually configure permissions in Admin Console 4. Verify role assignments</p>"},{"location":"config/fine-grained-admin-permissions-v2/#cannot-enable-permissions-for-resource","title":"Cannot Enable Permissions for Resource","text":"<p>Symptom: \"Permissions Enabled\" toggle is disabled</p> <p>Cause: FGAP V2 not enabled at realm level</p> <p>Solution: <pre><code>realm: \"my-realm\"\nadminPermissionsEnabled: true\n</code></pre></p> <p>Re-import configuration, then try enabling permissions again.</p>"},{"location":"config/fine-grained-admin-permissions-v2/#authorization-settings-import-fails","title":"Authorization Settings Import Fails","text":"<p>Symptom: Import fails when trying to configure <code>admin-permissions</code></p> <p>Error: <pre><code>Policy with name [xyz] already exists\n</code></pre></p> <p>Cause: Attempting to configure system-managed client</p> <p>Solution: Remove <code>admin-permissions</code> authorization settings from config file: <pre><code># Remove this:\n# clients:\n#   - clientId: \"admin-permissions\"\n#     authorizationSettings: ...\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#v1-configuration-still-present","title":"V1 Configuration Still Present","text":"<p>Symptom: Warnings about deprecated configuration</p> <p>Solution: Clean up V1 configuration: <pre><code># Remove V1 authorization from realm-management\nclients:\n  - clientId: \"realm-management\"\n    # Remove authorizationSettings block\n</code></pre></p>"},{"location":"config/fine-grained-admin-permissions-v2/#consequences","title":"Consequences","text":"<p>When using FGAP V2 in Keycloak 26.2+:</p> <ol> <li>No Config File Management: Permissions must be managed via Admin Console or API</li> <li>Migration Required: V1 configurations must be migrated manually</li> <li>Documentation Important: External documentation critical since permissions aren't in config files</li> <li>Cleaner Model: V2 provides more intuitive permission structure</li> <li>Custom Clients Unaffected: Your own client authorization continues to work normally</li> <li>API Changes: Must use dedicated FGAP V2 endpoints, not standard Authorization Services API</li> </ol>"},{"location":"config/fine-grained-admin-permissions-v2/#version-compatibility","title":"Version Compatibility","text":"Keycloak Version FGAP Version Client Config File Support &lt; 26.2 V1 <code>realm-management</code> \u2705 Full 26.2+ V2 <code>admin-permissions</code> \u274c Realm-level only <p>Recommendation: For Keycloak 26.2+, use <code>adminPermissionsEnabled: true</code> and manage detailed permissions through Admin Console.</p>"},{"location":"config/fine-grained-admin-permissions-v2/#example-complete-v2-setup","title":"Example: Complete V2 Setup","text":"<pre><code>realm: \"production\"\nenabled: true\nadminPermissionsEnabled: true\n\n# Define roles for permission management\nroles:\n  realm:\n    - name: \"client-administrator\"\n      description: \"Can manage production clients\"\n\n    - name: \"user-manager\"\n      description: \"Can manage production users\"\n\n    - name: \"group-manager\"\n      description: \"Can manage organizational groups\"\n\n# Define your custom clients (not admin-permissions)\nclients:\n  - clientId: \"production-app\"\n    enabled: true\n    authorizationServicesEnabled: true\n    authorizationSettings:\n      allowRemoteResourceManagement: true\n      policyEnforcementMode: \"ENFORCING\"\n\n      resources:\n        - name: \"admin-panel\"\n          type: \"urn:production-app:resources:admin\"\n          scopes:\n            - name: \"view\"\n            - name: \"edit\"\n\n      policies:\n        - name: \"admin-only\"\n          type: \"role\"\n          logic: \"POSITIVE\"\n          config:\n            roles: '[{\"id\":\"admin\",\"required\":true}]'\n\n        - name: \"admin-panel-permission\"\n          type: \"resource\"\n          logic: \"POSITIVE\"\n          config:\n            resources: '[\"admin-panel\"]'\n            applyPolicies: '[\"admin-only\"]'\n\n# Users with admin roles\nusers:\n  - username: \"client-admin\"\n    enabled: true\n    realmRoles:\n      - \"client-administrator\"\n\n  - username: \"user-admin\"\n    enabled: true\n    realmRoles:\n      - \"user-manager\"\n</code></pre> <p>After importing:</p> <ol> <li>Configure FGAP V2 permissions manually in Admin Console:</li> <li>Clients \u2192 Enable permissions \u2192 Assign to <code>client-administrator</code></li> <li>Users \u2192 Enable permissions \u2192 Assign to <code>user-manager</code></li> <li> <p>Groups \u2192 Enable permissions \u2192 Assign to <code>group-manager</code></p> </li> <li> <p>Document permissions in <code>PERMISSIONS.md</code>: <pre><code># FGAP V2 Permissions Configuration\n\n## Clients\n- Role: client-administrator\n- Scope: manage, view\n- Resources: All production clients\n\n## Users\n- Role: user-manager\n- Scope: manage, view, map-roles\n- Resources: All production users\n\n## Groups  \n- Role: group-manager\n- Scope: manage-members, view\n- Resources: All production groups\n</code></pre></p> </li> </ol>"},{"location":"config/minimal-configuration/","title":"Minimal Configurations From exported JSON","text":""},{"location":"config/minimal-configuration/#getting-minimal-import-after-realm-export","title":"Getting Minimal Import After Realm Export","text":"<p>This script is designed to clean up a Keycloak realm configuration file (in JSON format) by removing unnecessary fields, including all <code>id</code> fields, from the configuration. It is useful for simplifying the export of Keycloak realm data, especially when certain details like IDs are not needed for sharing or backup purposes.</p>"},{"location":"config/minimal-configuration/#features","title":"Features","text":"<ul> <li>Removes unnecessary default fields such as <code>accessTokenLifespan</code>, <code>offlineSessionIdleTimeout</code>, and others that are typically not needed for a reimport.</li> <li>Simplifies the realm configuration while retaining all necessary properties for further processing or importing into another Keycloak instance.</li> </ul>"},{"location":"config/minimal-configuration/#requirements","title":"Requirements","text":"<ul> <li>jq: This script requires <code>jq</code>, a command-line JSON processor, to manipulate the JSON data.</li> </ul> <p>You can install <code>jq</code> using the following commands:</p> <pre><code>- On Ubuntu/Debian:\n  ```bash\n  sudo apt-get install jq\n  ```\n- On macOS (with Homebrew):\n  ```bash\n  brew install jq\n  ```\n</code></pre>"},{"location":"config/minimal-configuration/#usage","title":"Usage","text":"<p>Ensure you have the Keycloak realm configuration file (in JSON format) that you want to clean. The file should be named <code>realm-config.json</code> or you can modify the script to use your desired file path.</p>"},{"location":"config/minimal-configuration/#download-or-copy-the-script","title":"Download or Copy the Script","text":"<pre><code>#!/bin/bash\n\nINPUT_FILE=\"realm-config.json\"\nOUTPUT_FILE=\"keycloak-realm-export-minimal.json\"\n\njq 'del(\n  .id, .containerId, .accessTokenLifespanForImplicitFlow,\n  .accessTokenLifespanForWebApps, .accessTokenLifespan, .offlineSessionIdleTimeout,\n  .accessTokenLifespanInSeconds, .ssoSessionIdleTimeout, .ssoSessionMaxLifespan,\n  .ssoSessionIdleTimeoutRememberMe, .ssoSessionMaxLifespanRememberMe,\n  .accessCodeLifespan, .accessCodeLifespanLogin, .accessCodeLifespanUserAction,\n  .accessCodeLifespanMobile, .notBefore, .registrationAllowed,\n  .registrationEmailAsUsername, .rememberMe, .verifyEmail, .resetPasswordFlow,\n  .editUsernameAllowed, .bruteForceProtected, .permanentLockout, .maxFailureWaitSeconds,\n  .minimumQuickLoginWaitSeconds, .waitIncrementSeconds, .quickLoginCheckMilliSeconds,\n  .maxDeltaTimeSeconds, .failureFactor, .requiredCredentials, .otpPolicyType,\n  .otpPolicyAlgorithm, .otpPolicyInitialCounter, .otpPolicyDigits, .otpPolicyLookAheadWindow,\n  .otpPolicyPeriod, .otpSupportedApplications, .webAuthnPolicyRpEntityName,\n  .webAuthnPolicyAttestationConveyancePreference, .webAuthnPolicyAuthenticatorAttachment,\n  .webAuthnPolicyRequireResidentKey, .webAuthnPolicyUserVerificationRequirement,\n  .webAuthnPolicyCreateTimeout, .webAuthnPolicyAssertionTimeout,\n  .webAuthnPolicyRegistrationRecoveryEnabled, .webAuthnPolicyRegistrationRecoveryCodesQuantity,\n  .webAuthnPolicyRegistrationTokenBindingRequired, .webAuthnPolicyRegistrationAttestationConveyancePreference,\n  .webAuthnPolicyRegistrationAuthenticatorSelectionCriteria, .keys\n) \n| walk(if type == \"object\" then del(.id) else . end)' &lt; \"$INPUT_FILE\" &gt; \"$OUTPUT_FILE\"\n\necho \"Minimal export saved to $OUTPUT_FILE\"\n</code></pre>"},{"location":"config/minimal-configuration/#make-the-script-executable","title":"make the script executable","text":"<pre><code>    chmod +x clean-realm-config.sh\n</code></pre> <p>Now execute the script, making sure that you have inputed the correct file paths.</p>"},{"location":"config/non-master-realm-authentication/","title":"Non-Master Realm Authentication","text":"<p>Starting with Keycloak 26.4.0, access to the global <code>/admin/serverinfo</code> endpoint is restricted to users authenticated in the <code>master</code> realm. When authenticating against a non-master realm to manage its configuration, keycloak-config-cli needs special configuration to bypass server info fetching and use alternative authentication methods.</p> <p>Related issues: #1343</p>"},{"location":"config/non-master-realm-authentication/#the-problem","title":"The Problem","text":"<p>Users encounter authentication and server info access issues when: - Authenticating with a user account in a non-master realm (e.g., <code>my-realm</code>) - Keycloak 26.4.0+ restricts <code>/admin/serverinfo</code> to master realm users only - keycloak-config-cli attempts to fetch server version information and fails with permission errors - The authenticated user doesn't have admin rights in the master realm - Organizations want to manage realms using realm-specific admin accounts - Security policies prevent granting master realm access to application administrators</p>"},{"location":"config/non-master-realm-authentication/#what-changed-in-keycloak-2640","title":"What Changed in Keycloak 26.4.0+","text":""},{"location":"config/non-master-realm-authentication/#before-keycloak-2640","title":"Before Keycloak 26.4.0","text":"<pre><code># This worked fine\njava -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.login-realm=my-realm \\\n  --keycloak.user=realm-admin \\\n  --keycloak.password=password \\\n  --import.files.locations=config.yaml\n</code></pre> <p>Behavior: - Any authenticated user could access <code>/admin/serverinfo</code> - keycloak-config-cli fetched server version successfully - Configuration import proceeded normally</p>"},{"location":"config/non-master-realm-authentication/#after-keycloak-2640","title":"After Keycloak 26.4.0","text":"<p>Same command fails: <pre><code># This now fails with 403 Forbidden\njava -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.login-realm=my-realm \\\n  --keycloak.user=realm-admin \\\n  --keycloak.password=password \\\n  --import.files.locations=config.yaml\n</code></pre></p> <p>Error: <pre><code>Error fetching server info: 403 Forbidden\nUser authenticated in 'my-realm' does not have permission to access /admin/serverinfo\n</code></pre></p> <p>Why it fails: - <code>/admin/serverinfo</code> is now restricted to master realm users only - Realm-specific admins no longer have access - keycloak-config-cli cannot determine Keycloak version - Import process halts</p>"},{"location":"config/non-master-realm-authentication/#the-solution-skip-server-info","title":"The Solution: Skip Server Info","text":"<p>Use the <code>--keycloak.skip-server-info=true</code> flag to bypass server info fetching.</p>"},{"location":"config/non-master-realm-authentication/#basic-configuration","title":"Basic Configuration","text":"<pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.login-realm=my-realm \\\n  --keycloak.user=realm-admin \\\n  --keycloak.password=password \\\n  --keycloak.skip-server-info=true \\\n  --import.files.locations=config.yaml\n</code></pre> <p>Result: - \u2705 Server info fetching is skipped - \u2705 Authentication succeeds against <code>my-realm</code> - \u2705 Configuration import proceeds normally - \u2705 No master realm access required</p>"},{"location":"config/non-master-realm-authentication/#with-environment-variables","title":"With Environment Variables","text":"<pre><code>export KEYCLOAK_URL=http://localhost:8080\nexport KEYCLOAK_LOGINREALM=my-realm\nexport KEYCLOAK_USER=realm-admin\nexport KEYCLOAK_PASSWORD=password\nexport KEYCLOAK_SKIPSERVERINFO=true\nexport IMPORT_FILES_LOCATIONS=config.yaml\n\njava -jar keycloak-config-cli.jar\n</code></pre>"},{"location":"config/non-master-realm-authentication/#docker-usage","title":"Docker Usage","text":"<pre><code>docker run \\\n  -e KEYCLOAK_URL=http://keycloak:8080 \\\n  -e KEYCLOAK_LOGINREALM=my-realm \\\n  -e KEYCLOAK_USER=realm-admin \\\n  -e KEYCLOAK_PASSWORD=password \\\n  -e KEYCLOAK_SKIPSERVERINFO=true \\\n  -e IMPORT_FILES_LOCATIONS=/config/realm-config.yaml \\\n  -v $(pwd)/config:/config \\\n  adorsys/keycloak-config-cli:latest\n</code></pre>"},{"location":"config/non-master-realm-authentication/#kubernetes-configmap","title":"Kubernetes ConfigMap","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: keycloak-config-cli\ndata:\n  KEYCLOAK_URL: \"http://keycloak:8080\"\n  KEYCLOAK_LOGINREALM: \"my-realm\"\n  KEYCLOAK_USER: \"realm-admin\"\n  KEYCLOAK_SKIPSERVERINFO: \"true\"\n  IMPORT_FILES_LOCATIONS: \"/config/realm-config.yaml\"\n</code></pre>"},{"location":"config/non-master-realm-authentication/#when-to-use-skip-server-info","title":"When to Use Skip Server Info","text":""},{"location":"config/non-master-realm-authentication/#use-skip-server-info-when","title":"\u2705 Use Skip Server Info When:","text":"<ol> <li> <p>Non-Master Realm Authentication</p> <ul> <li>Authenticating with users from realms other than <code>master</code></li> <li>Using realm-specific admin accounts</li> <li>Managing individual realms independently</li> </ul> </li> <li> <p>Keycloak 26.4.0+</p> <ul> <li>Running Keycloak version 26.4.0 or higher</li> <li>Encountering 403 Forbidden on <code>/admin/serverinfo</code></li> </ul> </li> <li> <p>Security Policies</p> <ul> <li>Organization restricts master realm access</li> <li>Principle of least privilege requires realm-scoped access</li> <li>Service accounts limited to specific realms</li> </ul> </li> <li> <p>Multi-Tenant Environments</p> <ul> <li>Each tenant has separate realm</li> <li>Tenant admins manage their own realms</li> <li>No cross-realm administrative access</li> </ul> </li> </ol>"},{"location":"config/non-master-realm-authentication/#dont-use-skip-server-info-when","title":"\u274c Don't Use Skip Server Info When:","text":"<ol> <li> <p>Master Realm Authentication</p> <ul> <li>Already authenticating against <code>master</code> realm</li> <li>User has appropriate master realm permissions</li> </ul> </li> <li> <p>Version-Specific Features Needed</p> <ul> <li>Relying on automatic version detection for compatibility</li> <li>Using features that vary by Keycloak version</li> </ul> </li> <li> <p>Keycloak &lt; 26.4.0</p> <ul> <li>Server info is accessible to all authenticated users</li> <li>No restriction in place</li> </ul> </li> </ol>"},{"location":"config/non-master-realm-authentication/#consequences-of-skipping-server-info","title":"Consequences of Skipping Server Info","text":""},{"location":"config/non-master-realm-authentication/#what-happens","title":"What Happens","text":"<ol> <li> <p>No Version Fetching</p> <ul> <li>keycloak-config-cli cannot automatically determine Keycloak version</li> <li>Version defaults to <code>unknown</code></li> </ul> </li> <li> <p>Alternative Health Check</p> <ul> <li>Uses authentication-based health check instead</li> <li>Validates connectivity via login realm authentication</li> </ul> </li> <li> <p>Compatibility Checks Limited</p> <ul> <li>Some version-specific compatibility checks may be skipped</li> <li>Features may behave differently across versions</li> </ul> </li> <li> <p>Manual Version Specification Recommended</p> <ul> <li>Can explicitly specify version if needed: <code>--keycloak.version=26.0.0</code></li> </ul> </li> </ol>"},{"location":"config/non-master-realm-authentication/#explicit-version-specification","title":"Explicit Version Specification","text":"<p>If you know your Keycloak version and want version-specific behavior: <pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.login-realm=my-realm \\\n  --keycloak.user=realm-admin \\\n  --keycloak.password=password \\\n  --keycloak.skip-server-info=true \\\n  --keycloak.version=26.0.0 \\\n  --import.files.locations=config.yaml\n</code></pre></p> <p>Benefits: - Version-specific features enabled - Better compatibility handling - Clearer in logs what version is expected</p>"},{"location":"config/non-master-realm-authentication/#complete-configuration-examples","title":"Complete Configuration Examples","text":""},{"location":"config/non-master-realm-authentication/#example-1-realm-specific-admin","title":"Example 1: Realm-Specific Admin","text":"<p>Scenario: Each realm has its own admin user, no master realm access. <pre><code># Authentication Configuration\n--keycloak.url=http://localhost:8080\n--keycloak.login-realm=corporate-realm\n--keycloak.user=corporate-admin\n--keycloak.password=SecurePassword123\n--keycloak.skip-server-info=true\n\n# Import Configuration  \n--import.files.locations=corporate-realm-config.yaml\n--import.remote-state.enabled=true\n--import.validate=true\n</code></pre></p> <p>YAML Configuration (<code>corporate-realm-config.yaml</code>): <pre><code>realm: \"corporate-realm\"\nenabled: true\ndisplayName: \"Corporate Realm\"\n\nclients:\n  - clientId: \"corporate-app\"\n    enabled: true\n    publicClient: true\n    redirectUris:\n      - \"https://app.corporate.com/*\"\n\nusers:\n  - username: \"john.doe\"\n    email: \"john.doe@corporate.com\"\n    enabled: true\n    realmRoles:\n      - \"user\"\n</code></pre></p>"},{"location":"config/non-master-realm-authentication/#example-2-multi-realm-management","title":"Example 2: Multi-Realm Management","text":"<p>Scenario: Managing multiple realms with separate admin accounts.</p> <p>Structure: <pre><code>config/\n\u251c\u2500\u2500 realm-a/\n\u2502   \u251c\u2500\u2500 config.yaml\n\u2502   \u2514\u2500\u2500 import.sh\n\u251c\u2500\u2500 realm-b/\n\u2502   \u251c\u2500\u2500 config.yaml\n\u2502   \u2514\u2500\u2500 import.sh\n\u2514\u2500\u2500 realm-c/\n    \u251c\u2500\u2500 config.yaml\n    \u2514\u2500\u2500 import.sh\n</code></pre></p> <p>Import Script (<code>realm-a/import.sh</code>): <pre><code>#!/bin/bash\n\njava -jar keycloak-config-cli.jar \\\n  --keycloak.url=${KEYCLOAK_URL} \\\n  --keycloak.login-realm=realm-a \\\n  --keycloak.user=${REALM_A_ADMIN_USER} \\\n  --keycloak.password=${REALM_A_ADMIN_PASSWORD} \\\n  --keycloak.skip-server-info=true \\\n  --import.files.locations=config/realm-a/config.yaml \\\n  --import.remote-state.enabled=true\n</code></pre></p>"},{"location":"config/non-master-realm-authentication/#example-3-cicd-pipeline","title":"Example 3: CI/CD Pipeline","text":"<p>Scenario: Automated realm configuration in CI/CD using service accounts.</p> <p>GitLab CI (.gitlab-ci.yml): <pre><code>deploy-realm-config:\n  stage: deploy\n  image: adorsys/keycloak-config-cli:latest\n  script:\n    - |\n      java -jar /opt/keycloak-config-cli.jar \\\n        --keycloak.url=${KEYCLOAK_URL} \\\n        --keycloak.login-realm=${REALM_NAME} \\\n        --keycloak.client-id=config-cli-client \\\n        --keycloak.client-secret=${CLIENT_SECRET} \\\n        --keycloak.grant-type=client_credentials \\\n        --keycloak.skip-server-info=true \\\n        --import.files.locations=config/${REALM_NAME}.yaml \\\n        --import.validate=true\n  only:\n    - main\n  environment:\n    name: production\n</code></pre></p> <p>Service Account Setup: 1. Create client <code>config-cli-client</code> in the target realm 2. Enable \"Service Accounts Enabled\" 3. Assign appropriate roles to service account 4. Use client credentials grant type</p>"},{"location":"config/non-master-realm-authentication/#example-4-kubernetes-deployment","title":"Example 4: Kubernetes Deployment","text":"<p>Scenario: Deploy keycloak-config-cli as a Kubernetes Job. <pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: keycloak-realm-config\n  namespace: keycloak\nspec:\n  template:\n    spec:\n      containers:\n      - name: config-cli\n        image: adorsys/keycloak-config-cli:latest\n        env:\n        - name: KEYCLOAK_URL\n          value: \"http://keycloak:8080\"\n        - name: KEYCLOAK_LOGINREALM\n          value: \"production-realm\"\n        - name: KEYCLOAK_USER\n          valueFrom:\n            secretKeyRef:\n              name: keycloak-admin\n              key: username\n        - name: KEYCLOAK_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: keycloak-admin\n              key: password\n        - name: KEYCLOAK_SKIPSERVERINFO\n          value: \"true\"\n        - name: KEYCLOAK_AVAILABILITYCHECK_ENABLED\n          value: \"true\"\n        - name: KEYCLOAK_AVAILABILITYCHECK_TIMEOUT\n          value: \"120s\"\n        - name: IMPORT_FILES_LOCATIONS\n          value: \"/config/realm-config.yaml\"\n        volumeMounts:\n        - name: config\n          mountPath: /config\n      volumes:\n      - name: config\n        configMap:\n          name: realm-configuration\n      restartPolicy: OnFailure\n</code></pre></p>"},{"location":"config/non-master-realm-authentication/#authentication-methods-with-non-master-realm","title":"Authentication Methods with Non-Master Realm","text":""},{"location":"config/non-master-realm-authentication/#method-1-usernamepassword-default","title":"Method 1: Username/Password (Default)","text":"<pre><code>--keycloak.login-realm=my-realm\n--keycloak.user=admin\n--keycloak.password=password\n--keycloak.skip-server-info=true\n</code></pre> <p>Use when: - Interactive or development environments - Credentials stored securely (secrets management) - User has appropriate realm management permissions</p>"},{"location":"config/non-master-realm-authentication/#method-2-client-credentials-service-account","title":"Method 2: Client Credentials (Service Account)","text":"<pre><code>--keycloak.login-realm=my-realm\n--keycloak.client-id=config-cli-client\n--keycloak.client-secret=ClientSecretHere\n--keycloak.grant-type=client_credentials\n--keycloak.skip-server-info=true\n</code></pre> <p>Setup: 1. Create confidential client in target realm 2. Enable \"Service Accounts Enabled\" 3. Disable \"Standard Flow\" and \"Direct Access Grants\" 4. Assign roles via \"Service Account Roles\" tab</p> <p>Use when: - Automated processes (CI/CD) - No user credentials available - Principle of least privilege (service account has only needed permissions)</p>"},{"location":"config/non-master-realm-authentication/#method-3-client-credentials-with-secret-in-file","title":"Method 3: Client Credentials with Secret in File","text":"<pre><code>export CLIENT_SECRET=$(cat /run/secrets/keycloak-client-secret)\n\njava -jar keycloak-config-cli.jar \\\n  --keycloak.login-realm=my-realm \\\n  --keycloak.client-id=config-cli-client \\\n  --keycloak.client-secret=${CLIENT_SECRET} \\\n  --keycloak.grant-type=client_credentials \\\n  --keycloak.skip-server-info=true \\\n  --import.files.locations=config.yaml\n</code></pre> <p>Use when: - Docker Swarm secrets - Kubernetes secrets mounted as files - Enhanced security for secret management</p>"},{"location":"config/non-master-realm-authentication/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"config/non-master-realm-authentication/#1-forgetting-skip-server-info-flag","title":"1. Forgetting skip-server-info Flag","text":"<p>Problem: <pre><code># Missing --keycloak.skip-server-info=true\njava -jar keycloak-config-cli.jar \\\n  --keycloak.login-realm=my-realm \\\n  --keycloak.user=admin \\\n  --keycloak.password=password \\\n  --import.files.locations=config.yaml\n</code></pre></p> <p>Error: <pre><code>403 Forbidden: /admin/serverinfo\n</code></pre></p> <p>Solution: Add the flag: <pre><code>--keycloak.skip-server-info=true\n</code></pre></p>"},{"location":"config/non-master-realm-authentication/#2-wrong-login-realm","title":"2. Wrong Login Realm","text":"<p>Problem: <pre><code>--keycloak.login-realm=master  # User exists in my-realm\n--keycloak.user=realm-admin\n</code></pre></p> <p>Error: <pre><code>401 Unauthorized: User not found\n</code></pre></p> <p>Solution: Use correct login realm: <pre><code>--keycloak.login-realm=my-realm\n--keycloak.user=realm-admin\n</code></pre></p>"},{"location":"config/non-master-realm-authentication/#3-insufficient-permissions","title":"3. Insufficient Permissions","text":"<p>Problem: User authenticated but cannot manage realm.</p> <p>Error: <pre><code>403 Forbidden: Insufficient permissions\n</code></pre></p> <p>Cause: User lacks required realm management roles.</p> <p>Solution: Assign appropriate roles: 1. In Keycloak Admin Console 2. Navigate to: Users \u2192 select user \u2192 Role Mappings 3. Assign client roles from <code>realm-management</code>:     - <code>manage-realm</code>     - <code>manage-clients</code>     - <code>manage-users</code>     - Or assign composite role: <code>realm-admin</code></p>"},{"location":"config/non-master-realm-authentication/#4-client-credentials-misconfiguration","title":"4. Client Credentials Misconfiguration","text":"<p>Problem: <pre><code>--keycloak.grant-type=client_credentials\n--keycloak.client-id=my-client\n--keycloak.client-secret=wrong-secret\n</code></pre></p> <p>Error: <pre><code>401 Unauthorized: Invalid client credentials\n</code></pre></p> <p>Solution: - Verify client secret is correct - Ensure \"Service Accounts Enabled\" is ON - Check client is confidential (not public)</p>"},{"location":"config/non-master-realm-authentication/#5-version-incompatibility-assumptions","title":"5. Version Incompatibility Assumptions","text":"<p>Problem: Assuming behavior is identical across Keycloak versions when skipping server info.</p> <p>Risk: Features may work differently in different versions.</p> <p>Solution: Explicitly specify version if using version-specific features: <pre><code>--keycloak.skip-server-info=true\n--keycloak.version=26.0.0\n</code></pre></p>"},{"location":"config/non-master-realm-authentication/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use Service Accounts in Production</p> <ul> <li>More secure than user credentials</li> <li>Easier to rotate secrets</li> <li>Better audit trail</li> </ul> </li> <li> <p>Always Specify skip-server-info for Non-Master</p> <ul> <li>Make it explicit in scripts and documentation</li> <li>Prevents unexpected failures after Keycloak upgrades</li> </ul> </li> <li> <p>Explicitly Set Version When Known</p> <ul> <li>Helps with compatibility checks</li> <li>Makes behavior more predictable</li> <li>Useful for debugging</li> </ul> </li> <li> <p>Use Availability Checks <pre><code>   --keycloak.availability-check.enabled=true\n   --keycloak.availability-check.timeout=120s\n</code></pre></p> </li> <li>Ensures Keycloak is ready before import</li> <li> <p>Prevents failures in CI/CD pipelines</p> </li> <li> <p>Separate Configs Per Realm</p> <ul> <li>Each realm has its own configuration file</li> <li>Each realm has its own admin credentials</li> <li>Clear separation of concerns</li> </ul> </li> <li> <p>Enable Validation <pre><code>   --import.validate=true\n</code></pre></p> </li> <li>Catches configuration errors early</li> <li> <p>Prevents partial imports</p> </li> <li> <p>Use Remote State <pre><code>   --import.remote-state.enabled=true\n</code></pre></p> </li> <li>Tracks managed resources</li> <li> <p>Safer for partial imports</p> </li> <li> <p>Secure Credential Management</p> <ul> <li>Use secrets management (Vault, Sealed Secrets, etc.)</li> <li>Never commit credentials to version control</li> <li>Rotate credentials regularly</li> </ul> </li> </ol>"},{"location":"config/non-master-realm-authentication/#troubleshooting","title":"Troubleshooting","text":""},{"location":"config/non-master-realm-authentication/#cannot-access-realm-after-authentication","title":"Cannot Access Realm After Authentication","text":"<p>Symptom: Authentication succeeds but cannot access realm configuration</p> <p>Diagnosis: <pre><code># Test authentication\ncurl -X POST \"http://localhost:8080/realms/my-realm/protocol/openid-connect/token\" \\\n  -d \"client_id=admin-cli\" \\\n  -d \"username=realm-admin\" \\\n  -d \"password=password\" \\\n  -d \"grant_type=password\"\n\n# If successful, test realm access\ncurl -H \"Authorization: Bearer $TOKEN\" \\\n  \"http://localhost:8080/admin/realms/my-realm\"\n</code></pre></p> <p>Possible causes: 1. User lacks realm management roles 2. Realm name mismatch 3. Client not authorized</p> <p>Solution: Verify user roles and permissions</p>"},{"location":"config/non-master-realm-authentication/#server-info-still-being-accessed","title":"Server Info Still Being Accessed","text":"<p>Symptom: Still seeing server info access attempts despite skip flag</p> <p>Diagnosis: Check effective configuration: <pre><code>java -jar keycloak-config-cli.jar \\\n  --debug \\\n  --keycloak.skip-server-info=true \\\n  ... other options ...\n</code></pre></p> <p>Possible causes: - Environment variable overriding command line - Configuration file conflicting - Old version of keycloak-config-cli</p> <p>Solution: - Check environment variables: <code>env | grep KEYCLOAK</code> - Update to latest keycloak-config-cli version - Ensure no conflicting configurations</p>"},{"location":"config/non-master-realm-authentication/#availability-check-fails","title":"Availability Check Fails","text":"<p>Symptom: Timeout waiting for Keycloak</p> <p>Error: <pre><code>Keycloak not available after 120s\n</code></pre></p> <p>Possible causes: 1. Keycloak not fully started 2. Wrong URL 3. Network connectivity issues 4. Realm not created yet</p> <p>Solution: - Increase timeout: <code>--keycloak.availability-check.timeout=300s</code> - Verify Keycloak is running: <code>curl http://localhost:8080</code> - Check realm exists</p>"},{"location":"config/non-master-realm-authentication/#migration-guide","title":"Migration Guide","text":""},{"location":"config/non-master-realm-authentication/#from-master-realm-to-non-master-realm-authentication","title":"From Master Realm to Non-Master Realm Authentication","text":"<p>Before (Keycloak &lt; 26.4.0): <pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.user=admin \\\n  --keycloak.password=admin \\\n  --import.files.locations=my-realm-config.yaml\n</code></pre></p> <p>After (Keycloak 26.4.0+):</p> <p>Option 1: Continue using master realm (not recommended) <pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.login-realm=master \\\n  --keycloak.user=admin \\\n  --keycloak.password=admin \\\n  --import.files.locations=my-realm-config.yaml\n</code></pre></p> <p>Option 2: Switch to realm-specific admin (recommended) <pre><code># 1. Create admin user in target realm\n# 2. Assign realm-admin role\n# 3. Use skip-server-info\n\njava -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.login-realm=my-realm \\\n  --keycloak.user=my-realm-admin \\\n  --keycloak.password=SecurePassword \\\n  --keycloak.skip-server-info=true \\\n  --import.files.locations=my-realm-config.yaml\n</code></pre></p> <p>Benefits of Option 2: - Follows principle of least privilege - Each realm independently managed - Better security separation - Aligns with multi-tenant architectures</p>"},{"location":"config/non-master-realm-authentication/#configuration-reference","title":"Configuration Reference","text":""},{"location":"config/non-master-realm-authentication/#cli-options","title":"CLI Options","text":"<pre><code># Required for non-master realm authentication (Keycloak 26.4.0+)\n--keycloak.skip-server-info=true\n\n# Optional: Explicit version specification\n--keycloak.version=26.0.0\n\n# Authentication realm\n--keycloak.login-realm=my-realm\n\n# User credentials\n--keycloak.user=admin\n--keycloak.password=password\n\n# OR client credentials\n--keycloak.client-id=config-cli\n--keycloak.client-secret=secret\n--keycloak.grant-type=client_credentials\n</code></pre>"},{"location":"config/non-master-realm-authentication/#environment-variables","title":"Environment Variables","text":"<pre><code># Required\nexport KEYCLOAK_SKIPSERVERINFO=true\nexport KEYCLOAK_LOGINREALM=my-realm\n\n# Optional\nexport KEYCLOAK_VERSION=26.0.0\n\n# Credentials\nexport KEYCLOAK_USER=admin\nexport KEYCLOAK_PASSWORD=password\n\n# OR\nexport KEYCLOAK_CLIENTID=config-cli\nexport KEYCLOAK_CLIENTSECRET=secret\nexport KEYCLOAK_GRANTTYPE=client_credentials\n</code></pre>"},{"location":"config/non-master-realm-authentication/#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>Principle of Least Privilege</p> <ul> <li>Use realm-specific admins</li> <li>Avoid master realm access when possible</li> <li>Grant only necessary permissions</li> </ul> </li> <li> <p>Service Account Best Practice</p> <ul> <li>Preferred over user credentials in automation</li> <li>Easier to audit and rotate</li> <li>Can be scoped to specific clients/roles</li> </ul> </li> <li> <p>Credential Management</p> <ul> <li>Use secrets management systems</li> <li>Rotate credentials regularly</li> <li>Never log or expose credentials</li> </ul> </li> <li> <p>Network Security</p> <ul> <li>Use HTTPS in production</li> <li>Enable SSL verification: <code>--keycloak.ssl-verify=true</code></li> <li>Consider VPN or private networks</li> </ul> </li> <li> <p>Audit Trail</p> <ul> <li>Monitor authentication attempts</li> <li>Log configuration changes</li> <li>Review service account usage</li> </ul> </li> </ol>"},{"location":"config/non-master-realm-authentication/#keycloak-version-compatibility","title":"Keycloak Version Compatibility","text":"Keycloak Version ServerInfo Access Skip Flag Required &lt; 26.4.0 All authenticated users No 26.4.0 - 26.x.x Master realm only Yes (for non-master) 27.0.0+ Master realm only Yes (for non-master) <p>Recommendation: Always use <code>--keycloak.skip-server-info=true</code> when authenticating against non-master realms for forward compatibility.</p>"},{"location":"config/otp-policy-configuration/","title":"OTP Policy Configuration","text":"<p>When configuring One-Time Password (OTP) policies in Keycloak realms, users often encounter issues where certain OTP policy settings appear to be ignored during import. Understanding how to properly configure OTP policies in keycloak-config-cli is essential for ensuring multi-factor authentication works as expected.</p> <p>Related issues: #847</p>"},{"location":"config/otp-policy-configuration/#the-problem","title":"The Problem","text":"<p>Users often encounter confusion when configuring OTP policies because: - Setting only <code>otpPolicyAlgorithm</code> in the configuration doesn't apply the change - Some OTP policy fields appear to be ignored during import - It's unclear which OTP policy fields must be configured together - Default values may override explicitly set values if the configuration is incomplete - The relationship between different OTP policy settings is not obvious</p>"},{"location":"config/otp-policy-configuration/#what-is-otp-policy","title":"What is OTP Policy?","text":"<p>OTP (One-Time Password) policy in Keycloak controls how Time-based One-Time Passwords (TOTP) and HMAC-based One-Time Passwords (HOTP) are generated and validated for multi-factor authentication.</p> <p>Key OTP Policy Settings: - Algorithm: Hash algorithm used (HmacSHA1, HmacSHA256, HmacSHA512) - Digits: Number of digits in the OTP (6 or 8) - Period: Time window for TOTP validity (in seconds) - Initial Counter: Starting counter value for HOTP - Look Ahead Window: Number of intervals to check for validation</p>"},{"location":"config/otp-policy-configuration/#why-otppolicyalgorithm-gets-ignored","title":"Why otpPolicyAlgorithm Gets Ignored","text":"<p>The <code>otpPolicyAlgorithm</code> field is ignored when:</p> <ol> <li>Incomplete OTP Policy Configuration: Setting only one field without others causes Keycloak to use default values</li> <li>Missing Required Fields: OTP policy requires a complete set of related fields to be valid</li> <li>Type Mismatch: Using <code>hotp</code> type without proper counter configuration</li> <li>Implicit Defaults: Keycloak applies defaults when the policy is partially configured</li> </ol>"},{"location":"config/otp-policy-configuration/#usage","title":"Usage","text":""},{"location":"config/otp-policy-configuration/#complete-otp-policy-configuration-totp","title":"Complete OTP Policy Configuration (TOTP)","text":"<p>Scenario: Configure a realm to use SHA-256 algorithm for TOTP with 6-digit codes. <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA256\"\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\n</code></pre></p> <p>Result:  - TOTP uses HmacSHA256 algorithm - Generates 6-digit codes - 30-second validity window - Looks ahead 1 time window for validation</p> <p>Important: All OTP policy fields should be specified together for consistent behavior.</p>"},{"location":"config/otp-policy-configuration/#incomplete-configuration-problematic","title":"Incomplete Configuration (Problematic)","text":"<p>Scenario: Attempting to change only the algorithm.</p> <p>Problematic Configuration: <pre><code>realm: \"myrealm\"\notpPolicyAlgorithm: \"HmacSHA256\"  # Only this field set\n</code></pre></p> <p>What happens: - The <code>otpPolicyAlgorithm</code> may be ignored - Keycloak uses default values for other fields - Results in inconsistent OTP configuration - May revert to default HmacSHA1 algorithm</p> <p>Why it fails: Keycloak's OTP policy expects a complete configuration. Partial updates may not be applied correctly.</p>"},{"location":"config/otp-policy-configuration/#hotp-configuration","title":"HOTP Configuration","text":"<p>Scenario: Configure HMAC-based OTP instead of time-based. <pre><code>realm: \"myrealm\"\notpPolicyType: \"hotp\"\notpPolicyAlgorithm: \"HmacSHA1\"\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 10\n</code></pre></p> <p>Result: - Uses counter-based OTP (HOTP) - HmacSHA1 algorithm - 6-digit codes - Looks ahead 10 counter values for validation</p> <p>Note: For HOTP, the <code>otpPolicyPeriod</code> field is not used.</p>"},{"location":"config/otp-policy-configuration/#high-security-otp-configuration","title":"High Security OTP Configuration","text":"<p>Scenario: Maximum security setup with SHA-512 and 8-digit codes. <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA512\"\notpPolicyDigits: 8\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\notpPolicySupportedApplications:\n  - \"totpAppFreeOTPName\"\n  - \"totpAppGoogleName\"\n</code></pre></p> <p>Result: - Most secure hash algorithm (SHA-512) - 8-digit codes for additional security - Compatible with Google Authenticator and FreeOTP</p>"},{"location":"config/otp-policy-configuration/#otp-policy-fields-reference","title":"OTP Policy Fields Reference","text":"Field Type Values Description Required <code>otpPolicyType</code> String <code>totp</code>, <code>hotp</code> Type of OTP Yes <code>otpPolicyAlgorithm</code> String <code>HmacSHA1</code>, <code>HmacSHA256</code>, <code>HmacSHA512</code> Hash algorithm Yes <code>otpPolicyDigits</code> Integer <code>6</code>, <code>8</code> Number of digits in OTP Yes <code>otpPolicyInitialCounter</code> Integer <code>0</code> or higher Initial counter (mainly for HOTP) Yes <code>otpPolicyLookAheadWindow</code> Integer <code>1</code> or higher Validation window size Yes <code>otpPolicyPeriod</code> Integer <code>30</code> (seconds) TOTP time window For TOTP"},{"location":"config/otp-policy-configuration/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"config/otp-policy-configuration/#1-setting-only-algorithm","title":"1. Setting Only Algorithm","text":"<p>Problem: <pre><code>realm: \"myrealm\"\notpPolicyAlgorithm: \"HmacSHA256\"\n# Other fields missing\n</code></pre></p> <p>What happens: Algorithm change is ignored, other fields use defaults.</p> <p>Solution: Always specify all OTP policy fields together: <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA256\"\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\n</code></pre></p>"},{"location":"config/otp-policy-configuration/#2-mixing-totp-and-hotp-settings","title":"2. Mixing TOTP and HOTP Settings","text":"<p>Problem: <pre><code>realm: \"myrealm\"\notpPolicyType: \"hotp\"\notpPolicyPeriod: 30  # Period is for TOTP, not HOTP\n</code></pre></p> <p>What happens: Conflicting configuration, unpredictable behavior.</p> <p>Solution: Use appropriate fields for the OTP type:</p> <p>For TOTP: <pre><code>otpPolicyType: \"totp\"\notpPolicyPeriod: 30  # Include period\n</code></pre></p> <p>For HOTP: <pre><code>otpPolicyType: \"hotp\"\n# Don't include otpPolicyPeriod\notpPolicyLookAheadWindow: 10  # Important for HOTP\n</code></pre></p>"},{"location":"config/otp-policy-configuration/#3-incorrect-algorithm-names","title":"3. Incorrect Algorithm Names","text":"<p>Problem: <pre><code>otpPolicyAlgorithm: \"SHA256\"  # Wrong!\n</code></pre></p> <p>Correct values: <pre><code>otpPolicyAlgorithm: \"HmacSHA256\"  # Correct\n# or\notpPolicyAlgorithm: \"HmacSHA1\"    # Correct\n# or\notpPolicyAlgorithm: \"HmacSHA512\"  # Correct\n</code></pre></p> <p>Note: Must include the <code>Hmac</code> prefix.</p>"},{"location":"config/otp-policy-configuration/#4-exporting-and-missing-fields","title":"4. Exporting and Missing Fields","text":"<p>Problem: Exporting a realm and re-importing without all OTP policy fields.</p> <p>When exporting: <pre><code>{\n  \"realm\": \"myrealm\",\n  \"otpPolicyAlgorithm\": \"HmacSHA256\",\n  // Other fields may be missing from export\n}\n</code></pre></p> <p>Solution: Ensure exported configuration includes all OTP policy fields, or add them manually: <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA256\"\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\n</code></pre></p>"},{"location":"config/otp-policy-configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Always Configure Complete OTP Policy: Include all related fields in a single configuration block</li> <li>Use Standard Values First: Start with standard settings (SHA256, 6 digits, 30 seconds) unless security requirements dictate otherwise</li> <li>Document Your Choices: Add comments explaining why specific OTP settings were chosen</li> <li>Test Authentication: After applying OTP policy changes, test with authenticator apps (Google Authenticator, FreeOTP)</li> <li>Version Control: Store OTP policy configurations in version control to track security policy changes</li> <li>Coordinate with Users: Changing OTP settings may require users to re-register their authenticators</li> </ol>"},{"location":"config/otp-policy-configuration/#configuration-template","title":"Configuration Template","text":"<p>Here's a complete template for OTP policy configuration: <pre><code>realm: \"myrealm\"\nenabled: true\n\n# OTP Policy Configuration\notpPolicyType: \"totp\"                    # totp or hotp\notpPolicyAlgorithm: \"HmacSHA256\"         # HmacSHA1, HmacSHA256, or HmacSHA512\notpPolicyDigits: 6                       # 6 or 8\notpPolicyInitialCounter: 0               # Starting counter\notpPolicyLookAheadWindow: 1              # Validation window\notpPolicyPeriod: 30                      # Time window in seconds (TOTP only)\n\n# Optional: Specify supported authenticator apps\notpPolicySupportedApplications:\n  - \"totpAppFreeOTPName\"\n  - \"totpAppGoogleName\"\n  - \"totpAppMicrosoftAuthenticatorName\"\n</code></pre></p>"},{"location":"config/otp-policy-configuration/#verifying-otp-policy-configuration","title":"Verifying OTP Policy Configuration","text":"<p>After applying the configuration, verify in Keycloak Admin Console:</p> <ol> <li>Navigate to: Realm Settings \u2192 Security defenses \u2192 OTP Policy</li> <li>Verify all settings match your configuration:</li> <li>OTP Type</li> <li>OTP Hash Algorithm</li> <li>Number of Digits</li> <li>Look Ahead Window</li> <li>OTP Token Period</li> </ol>"},{"location":"config/otp-policy-configuration/#algorithm-comparison","title":"Algorithm Comparison","text":"Algorithm Security Level Compatibility Recommendation HmacSHA1 Basic Universal Legacy systems only HmacSHA256 Strong Modern apps Recommended HmacSHA512 Maximum Modern apps High security environments"},{"location":"config/otp-policy-configuration/#migration-guide","title":"Migration Guide","text":""},{"location":"config/otp-policy-configuration/#from-sha1-to-sha256","title":"From SHA1 to SHA256","text":"<p>Scenario: Upgrading from legacy SHA1 to more secure SHA256.</p> <p>Steps:</p> <ol> <li> <p>Announce the change to users (they'll need to re-register authenticators)</p> </li> <li> <p>Update configuration: <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA256\"  # Changed from HmacSHA1\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\n</code></pre></p> </li> <li> <p>Apply the configuration using keycloak-config-cli</p> </li> <li> <p>Communicate to users:</p> </li> <li>Existing OTP credentials will need to be re-configured</li> <li>Users must remove old authenticator entries</li> <li>Users must re-scan QR code with authenticator app</li> </ol> <p>Important: This is a breaking change for existing users. Plan accordingly.</p>"},{"location":"config/otp-policy-configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"config/otp-policy-configuration/#otp-algorithm-not-applying","title":"OTP Algorithm Not Applying","text":"<p>Symptom: After import, OTP algorithm remains as default (HmacSHA1)</p> <p>Diagnosis: <pre><code># Check realm configuration\ncurl -s \"http://localhost:8080/admin/realms/myrealm\" \\\n  -H \"Authorization: Bearer $TOKEN\" | jq '.otpPolicy'\n</code></pre></p> <p>Possible causes: 1. Incomplete OTP policy configuration 2. Missing required fields 3. Configuration file not being imported 4. Import validation errors</p> <p>Solution: Use complete OTP policy configuration with all fields.</p>"},{"location":"config/otp-policy-configuration/#users-cant-authenticate-after-otp-change","title":"Users Can't Authenticate After OTP Change","text":"<p>Symptom: Users receive \"Invalid authenticator code\" errors</p> <p>Cause: OTP algorithm change requires users to re-register their authenticators</p> <p>Solution: 1. Users must delete old authenticator entry 2. In Keycloak, remove old OTP credential 3. User re-registers with new QR code 4. Test authentication with new code</p>"},{"location":"config/otp-policy-configuration/#configuration-options","title":"Configuration Options","text":"<pre><code># Validate configuration before import\n--import.validate=true\n\n# Check what will be changed\n--import.remote-state.enabled=true\n</code></pre>"},{"location":"config/otp-policy-configuration/#consequences","title":"Consequences","text":"<p>When configuring OTP policies in keycloak-config-cli:</p> <ol> <li>Complete Configuration Required: All OTP policy fields must be specified together for changes to apply correctly</li> <li>Algorithm Changes Break Existing Credentials: Users must re-register authenticators after algorithm changes</li> <li>Type Changes Are Disruptive: Switching between TOTP and HOTP requires user action</li> <li>Defaults May Override: Partial configurations may result in unexpected default values being applied</li> <li>No Backward Compatibility: Old authenticator entries won't work after policy changes</li> </ol>"},{"location":"config/otp-policy-configuration/#security-considerations","title":"Security Considerations","text":"<ol> <li>SHA1 is Deprecated: Avoid HmacSHA1 for new deployments; considered weak by modern standards</li> <li>8-digit Codes: More secure but less user-friendly; use for high-security environments</li> <li>Period Duration: 30 seconds is standard; shorter periods increase security but reduce usability</li> <li>Look Ahead Window: Larger windows reduce failed authentications but slightly decrease security</li> </ol>"},{"location":"config/otp-policy-configuration/#related-issues","title":"Related Issues","text":"<ul> <li>#847 - otpPolicyAlgorithm ignored</li> </ul>"},{"location":"config/otp-policy-configuration/#additional-resources","title":"Additional Resources","text":"<ul> <li>Keycloak OTP Policy Documentation</li> <li>TOTP RFC 6238</li> <li>HOTP RFC 4226</li> <li>Import Configuration# OTP Policy Configuration</li> </ul> <p>When configuring One-Time Password (OTP) policies in Keycloak realms, users often encounter issues where certain OTP policy settings appear to be ignored during import. Understanding how to properly configure OTP policies in keycloak-config-cli is essential for ensuring multi-factor authentication works as expected.</p> <p>Related issues: #847</p>"},{"location":"config/otp-policy-configuration/#the-problem_1","title":"The Problem","text":"<p>Users often encounter confusion when configuring OTP policies because: - Setting only <code>otpPolicyAlgorithm</code> in the configuration doesn't apply the change - Some OTP policy fields appear to be ignored during import - It's unclear which OTP policy fields must be configured together - Default values may override explicitly set values if the configuration is incomplete - The relationship between different OTP policy settings is not obvious</p>"},{"location":"config/otp-policy-configuration/#what-is-otp-policy_1","title":"What is OTP Policy?","text":"<p>OTP (One-Time Password) policy in Keycloak controls how Time-based One-Time Passwords (TOTP) and HMAC-based One-Time Passwords (HOTP) are generated and validated for multi-factor authentication.</p> <p>Key OTP Policy Settings: - Algorithm: Hash algorithm used (HmacSHA1, HmacSHA256, HmacSHA512) - Digits: Number of digits in the OTP (6 or 8) - Period: Time window for TOTP validity (in seconds) - Initial Counter: Starting counter value for HOTP - Look Ahead Window: Number of intervals to check for validation</p>"},{"location":"config/otp-policy-configuration/#why-otppolicyalgorithm-gets-ignored_1","title":"Why otpPolicyAlgorithm Gets Ignored","text":"<p>The <code>otpPolicyAlgorithm</code> field is ignored when:</p> <ol> <li>Incomplete OTP Policy Configuration: Setting only one field without others causes Keycloak to use default values</li> <li>Missing Required Fields: OTP policy requires a complete set of related fields to be valid</li> <li>Type Mismatch: Using <code>hotp</code> type without proper counter configuration</li> <li>Implicit Defaults: Keycloak applies defaults when the policy is partially configured</li> </ol>"},{"location":"config/otp-policy-configuration/#usage_1","title":"Usage","text":""},{"location":"config/otp-policy-configuration/#complete-otp-policy-configuration-totp_1","title":"Complete OTP Policy Configuration (TOTP)","text":"<p>Scenario: Configure a realm to use SHA-256 algorithm for TOTP with 6-digit codes. <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA256\"\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\n</code></pre></p> <p>Result:  - TOTP uses HmacSHA256 algorithm - Generates 6-digit codes - 30-second validity window - Looks ahead 1 time window for validation</p> <p>Important: All OTP policy fields should be specified together for consistent behavior.</p>"},{"location":"config/otp-policy-configuration/#incomplete-configuration-problematic_1","title":"Incomplete Configuration (Problematic)","text":"<p>Scenario: Attempting to change only the algorithm.</p> <p>Problematic Configuration: <pre><code>realm: \"myrealm\"\notpPolicyAlgorithm: \"HmacSHA256\"  # Only this field set\n</code></pre></p> <p>What happens: - The <code>otpPolicyAlgorithm</code> may be ignored - Keycloak uses default values for other fields - Results in inconsistent OTP configuration - May revert to default HmacSHA1 algorithm</p> <p>Why it fails: Keycloak's OTP policy expects a complete configuration. Partial updates may not be applied correctly.</p>"},{"location":"config/otp-policy-configuration/#hotp-configuration_1","title":"HOTP Configuration","text":"<p>Scenario: Configure HMAC-based OTP instead of time-based. <pre><code>realm: \"myrealm\"\notpPolicyType: \"hotp\"\notpPolicyAlgorithm: \"HmacSHA1\"\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 10\n</code></pre></p> <p>Result: - Uses counter-based OTP (HOTP) - HmacSHA1 algorithm - 6-digit codes - Looks ahead 10 counter values for validation</p> <p>Note: For HOTP, the <code>otpPolicyPeriod</code> field is not used.</p>"},{"location":"config/otp-policy-configuration/#high-security-otp-configuration_1","title":"High Security OTP Configuration","text":"<p>Scenario: Maximum security setup with SHA-512 and 8-digit codes. <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA512\"\notpPolicyDigits: 8\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\notpPolicySupportedApplications:\n  - \"totpAppFreeOTPName\"\n  - \"totpAppGoogleName\"\n</code></pre></p> <p>Result: - Most secure hash algorithm (SHA-512) - 8-digit codes for additional security - Compatible with Google Authenticator and FreeOTP</p>"},{"location":"config/otp-policy-configuration/#otp-policy-fields-reference_1","title":"OTP Policy Fields Reference","text":"Field Type Values Description Required <code>otpPolicyType</code> String <code>totp</code>, <code>hotp</code> Type of OTP Yes <code>otpPolicyAlgorithm</code> String <code>HmacSHA1</code>, <code>HmacSHA256</code>, <code>HmacSHA512</code> Hash algorithm Yes <code>otpPolicyDigits</code> Integer <code>6</code>, <code>8</code> Number of digits in OTP Yes <code>otpPolicyInitialCounter</code> Integer <code>0</code> or higher Initial counter (mainly for HOTP) Yes <code>otpPolicyLookAheadWindow</code> Integer <code>1</code> or higher Validation window size Yes <code>otpPolicyPeriod</code> Integer <code>30</code> (seconds) TOTP time window For TOTP"},{"location":"config/otp-policy-configuration/#common-pitfalls_1","title":"Common Pitfalls","text":""},{"location":"config/otp-policy-configuration/#1-setting-only-algorithm_1","title":"1. Setting Only Algorithm","text":"<p>Problem: <pre><code>realm: \"myrealm\"\notpPolicyAlgorithm: \"HmacSHA256\"\n# Other fields missing\n</code></pre></p> <p>What happens: Algorithm change is ignored, other fields use defaults.</p> <p>Solution: Always specify all OTP policy fields together: <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA256\"\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\n</code></pre></p>"},{"location":"config/otp-policy-configuration/#2-mixing-totp-and-hotp-settings_1","title":"2. Mixing TOTP and HOTP Settings","text":"<p>Problem: <pre><code>realm: \"myrealm\"\notpPolicyType: \"hotp\"\notpPolicyPeriod: 30  # Period is for TOTP, not HOTP\n</code></pre></p> <p>What happens: Conflicting configuration, unpredictable behavior.</p> <p>Solution: Use appropriate fields for the OTP type:</p> <p>For TOTP: <pre><code>otpPolicyType: \"totp\"\notpPolicyPeriod: 30  # Include period\n</code></pre></p> <p>For HOTP: <pre><code>otpPolicyType: \"hotp\"\n# Don't include otpPolicyPeriod\notpPolicyLookAheadWindow: 10  # Important for HOTP\n</code></pre></p>"},{"location":"config/otp-policy-configuration/#3-incorrect-algorithm-names_1","title":"3. Incorrect Algorithm Names","text":"<p>Problem: <pre><code>otpPolicyAlgorithm: \"SHA256\"  # Wrong!\n</code></pre></p> <p>Correct values: <pre><code>otpPolicyAlgorithm: \"HmacSHA256\"  # Correct\n# or\notpPolicyAlgorithm: \"HmacSHA1\"    # Correct\n# or\notpPolicyAlgorithm: \"HmacSHA512\"  # Correct\n</code></pre></p> <p>Note: Must include the <code>Hmac</code> prefix.</p>"},{"location":"config/otp-policy-configuration/#4-exporting-and-missing-fields_1","title":"4. Exporting and Missing Fields","text":"<p>Problem: Exporting a realm and re-importing without all OTP policy fields.</p> <p>When exporting: <pre><code>{\n  \"realm\": \"myrealm\",\n  \"otpPolicyAlgorithm\": \"HmacSHA256\",\n  // Other fields may be missing from export\n}\n</code></pre></p> <p>Solution: Ensure exported configuration includes all OTP policy fields, or add them manually: <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA256\"\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\n</code></pre></p>"},{"location":"config/otp-policy-configuration/#best-practices_1","title":"Best Practices","text":"<ol> <li>Always Configure Complete OTP Policy: Include all related fields in a single configuration block</li> <li>Use Standard Values First: Start with standard settings (SHA256, 6 digits, 30 seconds) unless security requirements dictate otherwise</li> <li>Document Your Choices: Add comments explaining why specific OTP settings were chosen</li> <li>Test Authentication: After applying OTP policy changes, test with authenticator apps (Google Authenticator, FreeOTP)</li> <li>Version Control: Store OTP policy configurations in version control to track security policy changes</li> <li>Coordinate with Users: Changing OTP settings may require users to re-register their authenticators</li> </ol>"},{"location":"config/otp-policy-configuration/#configuration-template_1","title":"Configuration Template","text":"<p>Here's a complete template for OTP policy configuration: <pre><code>realm: \"myrealm\"\nenabled: true\n\n# OTP Policy Configuration\notpPolicyType: \"totp\"                    # totp or hotp\notpPolicyAlgorithm: \"HmacSHA256\"         # HmacSHA1, HmacSHA256, or HmacSHA512\notpPolicyDigits: 6                       # 6 or 8\notpPolicyInitialCounter: 0               # Starting counter\notpPolicyLookAheadWindow: 1              # Validation window\notpPolicyPeriod: 30                      # Time window in seconds (TOTP only)\n\n# Optional: Specify supported authenticator apps\notpPolicySupportedApplications:\n  - \"totpAppFreeOTPName\"\n  - \"totpAppGoogleName\"\n  - \"totpAppMicrosoftAuthenticatorName\"\n</code></pre></p>"},{"location":"config/otp-policy-configuration/#verifying-otp-policy-configuration_1","title":"Verifying OTP Policy Configuration","text":"<p>After applying the configuration, verify in Keycloak Admin Console:</p> <ol> <li>Navigate to: Realm Settings \u2192 Security defenses \u2192 OTP Policy</li> <li>Verify all settings match your configuration:</li> <li>OTP Type</li> <li>OTP Hash Algorithm</li> <li>Number of Digits</li> <li>Look Ahead Window</li> <li>OTP Token Period</li> </ol>"},{"location":"config/otp-policy-configuration/#algorithm-comparison_1","title":"Algorithm Comparison","text":"Algorithm Security Level Compatibility Recommendation HmacSHA1 Basic Universal Legacy systems only HmacSHA256 Strong Modern apps Recommended HmacSHA512 Maximum Modern apps High security environments"},{"location":"config/otp-policy-configuration/#migration-guide_1","title":"Migration Guide","text":""},{"location":"config/otp-policy-configuration/#from-sha1-to-sha256_1","title":"From SHA1 to SHA256","text":"<p>Scenario: Upgrading from legacy SHA1 to more secure SHA256.</p> <p>Steps:</p> <ol> <li> <p>Announce the change to users (they'll need to re-register authenticators)</p> </li> <li> <p>Update configuration: <pre><code>realm: \"myrealm\"\notpPolicyType: \"totp\"\notpPolicyAlgorithm: \"HmacSHA256\"  # Changed from HmacSHA1\notpPolicyDigits: 6\notpPolicyInitialCounter: 0\notpPolicyLookAheadWindow: 1\notpPolicyPeriod: 30\n</code></pre></p> </li> <li> <p>Apply the configuration using keycloak-config-cli</p> </li> <li> <p>Communicate to users:</p> </li> <li>Existing OTP credentials will need to be re-configured</li> <li>Users must remove old authenticator entries</li> <li>Users must re-scan QR code with authenticator app</li> </ol> <p>Important: This is a breaking change for existing users. Plan accordingly.</p>"},{"location":"config/otp-policy-configuration/#troubleshooting_1","title":"Troubleshooting","text":""},{"location":"config/otp-policy-configuration/#otp-algorithm-not-applying_1","title":"OTP Algorithm Not Applying","text":"<p>Symptom: After import, OTP algorithm remains as default (HmacSHA1)</p> <p>Diagnosis: <pre><code># Check realm configuration\ncurl -s \"http://localhost:8080/admin/realms/myrealm\" \\\n  -H \"Authorization: Bearer $TOKEN\" | jq '.otpPolicy'\n</code></pre></p> <p>Possible causes: 1. Incomplete OTP policy configuration 2. Missing required fields 3. Configuration file not being imported 4. Import validation errors</p> <p>Solution: Use complete OTP policy configuration with all fields.</p>"},{"location":"config/otp-policy-configuration/#users-cant-authenticate-after-otp-change_1","title":"Users Can't Authenticate After OTP Change","text":"<p>Symptom: Users receive \"Invalid authenticator code\" errors</p> <p>Cause: OTP algorithm change requires users to re-register their authenticators</p> <p>Solution: 1. Users must delete old authenticator entry 2. In Keycloak, remove old OTP credential 3. User re-registers with new QR code 4. Test authentication with new code</p>"},{"location":"config/otp-policy-configuration/#configuration-options_1","title":"Configuration Options","text":"<pre><code># Validate configuration before import\n--import.validate=true\n\n# Check what will be changed\n--import.remote-state.enabled=true\n</code></pre>"},{"location":"config/otp-policy-configuration/#consequences_1","title":"Consequences","text":"<p>When configuring OTP policies in keycloak-config-cli:</p> <ol> <li>Complete Configuration Required: All OTP policy fields must be specified together for changes to apply correctly</li> <li>Algorithm Changes Break Existing Credentials: Users must re-register authenticators after algorithm changes</li> <li>Type Changes Are Disruptive: Switching between TOTP and HOTP requires user action</li> <li>Defaults May Override: Partial configurations may result in unexpected default values being applied</li> <li>No Backward Compatibility: Old authenticator entries won't work after policy changes</li> </ol>"},{"location":"config/otp-policy-configuration/#security-considerations_1","title":"Security Considerations","text":"<ol> <li>SHA1 is Deprecated: Avoid HmacSHA1 for new deployments; considered weak by modern standards</li> <li>8-digit Codes: More secure but less user-friendly; use for high-security environments</li> <li>Period Duration: 30 seconds is standard; shorter periods increase security but reduce usability</li> <li>Look Ahead Window: Larger windows reduce failed authentications but slightly decrease security</li> </ol>"},{"location":"config/otp-policy-configuration/#related-issues_1","title":"Related Issues","text":"<ul> <li>#847 - otpPolicyAlgorithm ignored</li> </ul>"},{"location":"config/otp-policy-configuration/#additional-resources_1","title":"Additional Resources","text":"<ul> <li>Keycloak OTP Policy Documentation</li> <li>TOTP RFC 6238</li> <li>HOTP RFC 4226</li> <li>Import Configuration</li> </ul>"},{"location":"config/partial-imports/","title":"Partial Imports","text":"<p>When managing Keycloak configurations, you often need to update only specific parts of a realm without affecting other components. Understanding how to perform partial imports allows you to maintain modular, focused configuration files and avoid unintended changes to unrelated realm settings.</p> <p>Related issues: #1161</p>"},{"location":"config/partial-imports/#the-problem","title":"The Problem","text":"<p>Users often encounter challenges when trying to update specific realm components because: - Running a full realm import can affect unrelated configurations - It's unclear how to update only clients without touching users or groups - Separate teams managing different components need isolated configuration files - Fear of accidentally deleting resources not included in the import file - Uncertainty about which resources will be managed vs. left untouched - Complex realms require modular configuration management</p>"},{"location":"config/partial-imports/#what-are-partial-imports","title":"What are Partial Imports?","text":"<p>Partial imports allow you to import only specific parts of a realm configuration without affecting other components. Instead of managing the entire realm in one large file, you can:</p> <ul> <li>Update only clients without touching users</li> <li>Add authentication flows without modifying existing ones</li> <li>Manage groups separately from roles</li> <li>Update specific client scopes without affecting others</li> <li>Split configuration across multiple files by component type or team ownership</li> </ul>"},{"location":"config/partial-imports/#how-partial-imports-work","title":"How Partial Imports Work","text":"<p>With <code>import.remote-state.enabled=true</code> (default), keycloak-config-cli tracks which resources it manages. This enables true partial imports where:</p> <ol> <li>Only specified resources are managed - Resources in your config file are created/updated</li> <li>Unspecified resources are untouched - Resources not in your config remain unchanged</li> <li>Removal is explicit - Only resources previously managed by keycloak-config-cli can be deleted</li> <li>Multiple files can coexist - Different files can manage different parts of the realm</li> </ol>"},{"location":"config/partial-imports/#usage","title":"Usage","text":""},{"location":"config/partial-imports/#importing-only-clients","title":"Importing Only Clients","text":"<p>Scenario: You want to add or update clients without affecting users, groups, or other realm settings.</p> <p>File: <code>clients-config.yaml</code> <pre><code>realm: \"myrealm\"\nclients:\n  - clientId: \"app-frontend\"\n    enabled: true\n    publicClient: true\n    redirectUris:\n      - \"https://app.example.com/*\"\n    webOrigins:\n      - \"https://app.example.com\"\n\n  - clientId: \"app-backend\"\n    enabled: true\n    publicClient: false\n    serviceAccountsEnabled: true\n    clientAuthenticatorType: \"client-secret\"\n</code></pre></p> <p>Result: - Only the two clients are created/updated - Existing users remain unchanged - Existing groups remain unchanged - Other clients not in this file remain untouched - No realm settings are modified</p> <p>Import command: <pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.user=admin \\\n  --keycloak.password=admin \\\n  --import.files.locations=clients-config.yaml\n</code></pre></p>"},{"location":"config/partial-imports/#importing-only-users","title":"Importing Only Users","text":"<p>Scenario: HR team manages users in a separate file from the infrastructure team's client configurations.</p> <p>File: <code>users-config.yaml</code> <pre><code>realm: \"myrealm\"\nusers:\n  - username: \"john.doe\"\n    email: \"john.doe@example.com\"\n    firstName: \"John\"\n    lastName: \"Doe\"\n    enabled: true\n    realmRoles:\n      - \"user\"\n    credentials:\n      - type: \"password\"\n        value: \"temp123\"\n        temporary: true\n\n  - username: \"jane.smith\"\n    email: \"jane.smith@example.com\"\n    firstName: \"Jane\"\n    lastName: \"Smith\"\n    enabled: true\n    realmRoles:\n      - \"user\"\n      - \"manager\"\n</code></pre></p> <p>Result: - Only users are managed - Clients remain unchanged - Groups remain unchanged - Authentication flows remain unchanged</p>"},{"location":"config/partial-imports/#importing-only-groups","title":"Importing Only Groups","text":"<p>Scenario: Manage organizational structure separately from user accounts.</p> <p>File: <code>groups-config.yaml</code> <pre><code>realm: \"myrealm\"\ngroups:\n  - name: \"Engineering\"\n    path: \"/Engineering\"\n    attributes:\n      department: [\"engineering\"]\n    subGroups:\n      - name: \"Backend\"\n        path: \"/Engineering/Backend\"\n      - name: \"Frontend\"\n        path: \"/Engineering/Frontend\"\n\n  - name: \"Sales\"\n    path: \"/Sales\"\n    attributes:\n      department: [\"sales\"]\n</code></pre></p> <p>Result: - Only groups are managed - Users remain unchanged - User group memberships added via this file are managed - Other realm components remain unchanged</p>"},{"location":"config/partial-imports/#importing-only-authentication-flows","title":"Importing Only Authentication Flows","text":"<p>Scenario: Security team manages authentication flows independently.</p> <p>File: <code>auth-flows-config.yaml</code> <pre><code>realm: \"myrealm\"\nauthenticationFlows:\n  - alias: \"browser-with-mfa\"\n    description: \"Browser flow with mandatory MFA\"\n    providerId: \"basic-flow\"\n    topLevel: true\n    builtIn: false\n    authenticationExecutions:\n      - authenticator: \"auth-cookie\"\n        requirement: \"ALTERNATIVE\"\n        priority: 10\n\n      - authenticator: \"identity-provider-redirector\"\n        requirement: \"ALTERNATIVE\"\n        priority: 20\n\n      - authenticator: \"auth-username-password-form\"\n        requirement: \"REQUIRED\"\n        priority: 30\n\n      - authenticator: \"auth-otp-form\"\n        requirement: \"REQUIRED\"\n        priority: 40\n</code></pre></p> <p>Result: - Only authentication flows are managed - Browser binding not changed unless explicitly set - Clients remain unchanged - Users remain unchanged</p>"},{"location":"config/partial-imports/#importing-client-scopes-only","title":"Importing Client Scopes Only","text":"<p>Scenario: Create reusable scopes without affecting existing clients.</p> <p>File: <code>client-scopes-config.yaml</code> <pre><code>realm: \"myrealm\"\nclientScopes:\n  - name: \"custom-claims\"\n    description: \"Custom application claims\"\n    protocol: \"openid-connect\"\n    attributes:\n      include.in.token.scope: \"true\"\n      display.on.consent.screen: \"true\"\n    protocolMappers:\n      - name: \"department-mapper\"\n        protocol: \"openid-connect\"\n        protocolMapper: \"oidc-usermodel-attribute-mapper\"\n        config:\n          user.attribute: \"department\"\n          claim.name: \"department\"\n          jsonType.label: \"String\"\n          id.token.claim: \"true\"\n          access.token.claim: \"true\"\n</code></pre></p> <p>Result: - Only client scopes are created/updated - Existing clients are not modified - Client scope assignments to clients remain unchanged unless explicitly set</p>"},{"location":"config/partial-imports/#multiple-file-strategy","title":"Multiple File Strategy","text":""},{"location":"config/partial-imports/#organizing-by-component-type","title":"Organizing by Component Type","text":"<p>Structure: <pre><code>config/\n\u251c\u2500\u2500 realm-settings.yaml      # Basic realm settings\n\u251c\u2500\u2500 clients.yaml             # All clients\n\u251c\u2500\u2500 users.yaml               # All users\n\u251c\u2500\u2500 groups.yaml              # Group structure\n\u251c\u2500\u2500 roles.yaml               # Realm and client roles\n\u251c\u2500\u2500 auth-flows.yaml          # Authentication flows\n\u2514\u2500\u2500 client-scopes.yaml       # Reusable scopes\n</code></pre></p> <p>Import all files: <pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.user=admin \\\n  --keycloak.password=admin \\\n  --import.files.locations='config/*.yaml'\n</code></pre></p> <p>Import specific component: <pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.user=admin \\\n  --keycloak.password=admin \\\n  --import.files.locations=config/clients.yaml\n</code></pre></p>"},{"location":"config/partial-imports/#organizing-by-environment","title":"Organizing by Environment","text":"<p>Structure: <pre><code>config/\n\u251c\u2500\u2500 base/\n\u2502   \u251c\u2500\u2500 clients.yaml         # Common clients\n\u2502   \u2514\u2500\u2500 roles.yaml           # Common roles\n\u251c\u2500\u2500 dev/\n\u2502   \u251c\u2500\u2500 realm-settings.yaml  # Dev-specific settings\n\u2502   \u2514\u2500\u2500 users.yaml           # Dev test users\n\u251c\u2500\u2500 staging/\n\u2502   \u2514\u2500\u2500 realm-settings.yaml  # Staging settings\n\u2514\u2500\u2500 production/\n    \u2514\u2500\u2500 realm-settings.yaml  # Production settings\n</code></pre></p> <p>Import base + environment: <pre><code># Import base configuration\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations='config/base/*.yaml'\n\n# Then import environment-specific\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations='config/production/*.yaml'\n</code></pre></p>"},{"location":"config/partial-imports/#organizing-by-team","title":"Organizing by Team","text":"<p>Structure:</p> <pre><code>config/\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u251c\u2500\u2500 clients.yaml         # Infrastructure team manages clients\n\u2502   \u2514\u2500\u2500 auth-flows.yaml      # Authentication configuration\n\u251c\u2500\u2500 hr/\n\u2502   \u2514\u2500\u2500 users.yaml           # HR team manages users\n\u2514\u2500\u2500 security/\n    \u251c\u2500\u2500 roles.yaml           # Security team manages roles\n    \u2514\u2500\u2500 groups.yaml          # Permission groups\n</code></pre> <p>Each team imports their files: <pre><code># Infrastructure team\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations='config/infrastructure/*.yaml'\n\n# HR team\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations='config/hr/*.yaml'\n</code></pre></p>"},{"location":"config/partial-imports/#behavior-with-remote-state","title":"Behavior with Remote State","text":""},{"location":"config/partial-imports/#with-remote-state-enabled-default","title":"With Remote State Enabled (Default)","text":"<p><pre><code># File 1: clients.yaml\nrealm: \"myrealm\"\nclients:\n  - clientId: \"app-1\"\n    enabled: true\n</code></pre> <pre><code># File 2: users.yaml\nrealm: \"myrealm\"\nusers:\n  - username: \"user-1\"\n    enabled: true\n</code></pre></p> <p>Behavior: 1. Import <code>clients.yaml</code> \u2192 Creates/updates <code>app-1</code> client 2. Import <code>users.yaml</code> \u2192 Creates/updates <code>user-1</code> user 3. <code>app-1</code> client remains unchanged by user import 4. <code>user-1</code> user remains unchanged by client import 5. Both files can be maintained independently</p> <p>This is true partial import!</p>"},{"location":"config/partial-imports/#without-remote-state","title":"Without Remote State","text":"<pre><code>--import.remote-state.enabled=false\n</code></pre> <p>Behavior: - Each import attempts to sync the entire realm - Resources not in the file may be removed - Partial imports are risky without remote state - Not recommended for partial import strategy</p> <p>Important: Always use <code>import.remote-state.enabled=true</code> (default) for partial imports.</p>"},{"location":"config/partial-imports/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"config/partial-imports/#1-expecting-unmanaged-resources-to-update","title":"1. Expecting Unmanaged Resources to Update","text":"<p>Problem: <pre><code># First import\nrealm: \"myrealm\"\nclients:\n  - clientId: \"app-1\"\n    enabled: true\n</code></pre></p> <p>Later, manually creating <code>app-2</code> via Admin Console, then expecting: <pre><code># Second import\nrealm: \"myrealm\"\nclients:\n  - clientId: \"app-1\"\n    enabled: true\n  - clientId: \"app-2\"  # Manually created\n    enabled: false     # Trying to disable it\n</code></pre></p> <p>Result: If <code>app-2</code> was created manually (not via keycloak-config-cli), changes to it may not be applied consistently.</p> <p>Solution: Once you start managing a resource with keycloak-config-cli, always manage it through config files, not the Admin Console.</p>"},{"location":"config/partial-imports/#2-conflicting-imports-from-multiple-files","title":"2. Conflicting Imports from Multiple Files","text":"<p>Problem: <pre><code># File 1: team-a.yaml\nrealm: \"myrealm\"\nclients:\n  - clientId: \"shared-client\"\n    enabled: true\n</code></pre> <pre><code># File 2: team-b.yaml\nrealm: \"myrealm\"\nclients:\n  - clientId: \"shared-client\"\n    enabled: false  # Conflicts with File 1\n</code></pre></p> <p>Result: Last import wins. Client state depends on import order.</p> <p>Solution: Establish ownership rules: - One file per resource - Use naming conventions (e.g., <code>team-a-*</code> clients) - Document which team owns which resources</p>"},{"location":"config/partial-imports/#3-incomplete-partial-configuration","title":"3. Incomplete Partial Configuration","text":"<p>Problem: <pre><code># Trying to update only one field of a client\nrealm: \"myrealm\"\nclients:\n  - clientId: \"existing-client\"\n    enabled: false  # Only this field\n</code></pre></p> <p>Result: Other fields of the client may be reset to defaults or remain unchanged unpredictably.</p> <p>Solution: Include all relevant fields when updating a resource: <pre><code>realm: \"myrealm\"\nclients:\n  - clientId: \"existing-client\"\n    enabled: false\n    publicClient: true\n    redirectUris:\n      - \"https://app.example.com/*\"\n    # Include all fields you want to maintain\n</code></pre></p>"},{"location":"config/partial-imports/#4-removing-resources-across-files","title":"4. Removing Resources Across Files","text":"<p>Problem: Resource managed by File A, trying to remove it via File B.</p> <p>File A (initial): <pre><code>realm: \"myrealm\"\nclients:\n  - clientId: \"app-1\"\n</code></pre></p> <p>File B (attempting removal): <pre><code>realm: \"myrealm\"\nclients: []  # Empty, expecting app-1 to be deleted\n</code></pre></p> <p>Result: <code>app-1</code> is not deleted because File B didn't create it.</p> <p>Solution: Remove resources from the original file that created them: - Delete from File A, or - Use the same file consistently for a resource</p>"},{"location":"config/partial-imports/#5-forgetting-realm-name","title":"5. Forgetting Realm Name","text":"<p>Problem: <pre><code># Missing realm name\nclients:\n  - clientId: \"app-1\"\n</code></pre></p> <p>Result: Import fails or applies to wrong realm.</p> <p>Solution: Always specify the realm: <pre><code>realm: \"myrealm\"  # Always include this\nclients:\n  - clientId: \"app-1\"\n</code></pre></p>"},{"location":"config/partial-imports/#best-practices","title":"Best Practices","text":"<ol> <li>Always Use Remote State: Keep <code>import.remote-state.enabled=true</code> for partial imports</li> <li>One Resource, One Owner: Assign each resource to a single configuration file</li> <li>Organize Logically: Group related resources (e.g., all clients together, all users together)</li> <li>Use Naming Conventions: Prefix resources by team/purpose (e.g., <code>frontend-*</code>, <code>backend-*</code>)</li> <li>Document Ownership: Maintain a README showing which file manages which resources</li> <li>Version Control Everything: Store all configuration files in Git</li> <li>Small, Focused Files: Better than one large file for maintainability</li> <li>Validate Before Import: Use <code>--import.validate=true</code> to catch errors</li> <li>Test in Development: Apply partial imports to dev environment first</li> <li>Automate in CI/CD: Use separate jobs for different component imports</li> </ol>"},{"location":"config/partial-imports/#configuration-options","title":"Configuration Options","text":"<pre><code># Enable remote state for partial imports (default)\n--import.remote-state.enabled=true\n\n# Validate configuration before import\n--import.validate=true\n\n# Import multiple files with pattern\n--import.files.locations='config/*.yaml'\n\n# Import specific files (comma-separated)\n--import.files.locations='config/clients.yaml,config/users.yaml'\n\n# Enable parallel import for performance\n--import.parallel=true\n</code></pre>"},{"location":"config/partial-imports/#import-strategies","title":"Import Strategies","text":""},{"location":"config/partial-imports/#strategy-1-component-based","title":"Strategy 1: Component-Based","text":"<p>Best for: Large teams with specialized roles <pre><code>config/\n\u251c\u2500\u2500 01-realm-settings.yaml\n\u251c\u2500\u2500 02-roles.yaml\n\u251c\u2500\u2500 03-groups.yaml\n\u251c\u2500\u2500 04-clients.yaml\n\u251c\u2500\u2500 05-users.yaml\n\u2514\u2500\u2500 06-auth-flows.yaml\n</code></pre></p> <p>Benefits: - Clear separation of concerns - Different teams own different files - Easy to understand structure</p>"},{"location":"config/partial-imports/#strategy-2-application-based","title":"Strategy 2: Application-Based","text":"<p>Best for: Microservices architecture <pre><code>config/\n\u251c\u2500\u2500 app-frontend/\n\u2502   \u251c\u2500\u2500 client.yaml\n\u2502   \u251c\u2500\u2500 roles.yaml\n\u2502   \u2514\u2500\u2500 scopes.yaml\n\u251c\u2500\u2500 app-backend/\n\u2502   \u251c\u2500\u2500 client.yaml\n\u2502   \u2514\u2500\u2500 service-account.yaml\n\u2514\u2500\u2500 shared/\n    \u251c\u2500\u2500 common-roles.yaml\n    \u2514\u2500\u2500 common-groups.yaml\n</code></pre></p> <p>Benefits: - Application-centric organization - Easy to deploy/remove entire applications - Clear dependencies</p>"},{"location":"config/partial-imports/#strategy-3-environment-based","title":"Strategy 3: Environment-Based","text":"<p>Best for: Multiple environments (dev, staging, prod) <pre><code>config/\n\u251c\u2500\u2500 base/              # Common to all environments\n\u2502   \u251c\u2500\u2500 clients.yaml\n\u2502   \u2514\u2500\u2500 roles.yaml\n\u251c\u2500\u2500 overlays/\n\u2502   \u251c\u2500\u2500 dev/\n\u2502   \u2502   \u2514\u2500\u2500 realm-settings.yaml\n\u2502   \u251c\u2500\u2500 staging/\n\u2502   \u2502   \u2514\u2500\u2500 realm-settings.yaml\n\u2502   \u2514\u2500\u2500 production/\n\u2502       \u2514\u2500\u2500 realm-settings.yaml\n</code></pre></p> <p>Benefits: - Reuse common configuration - Environment-specific overrides - Consistent base across environments</p>"},{"location":"config/partial-imports/#real-world-example","title":"Real-World Example","text":""},{"location":"config/partial-imports/#scenario-e-commerce-platform","title":"Scenario: E-commerce Platform","text":"<p>Teams: - Infrastructure: Manages clients and authentication - Backend: Manages service accounts - Frontend: Manages public clients - HR: Manages users</p> <p>Configuration Structure: <pre><code>config/\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u251c\u2500\u2500 realm-settings.yaml\n\u2502   \u2502   realm: \"ecommerce\"\n\u2502   \u2502   displayName: \"E-commerce Platform\"\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 auth-flows.yaml\n\u2502       realm: \"ecommerce\"\n\u2502       authenticationFlows: [...]\n\u2502\n\u251c\u2500\u2500 backend/\n\u2502   \u2514\u2500\u2500 service-clients.yaml\n\u2502       realm: \"ecommerce\"\n\u2502       clients:\n\u2502         - clientId: \"order-service\"\n\u2502         - clientId: \"payment-service\"\n\u2502         - clientId: \"inventory-service\"\n\u2502\n\u251c\u2500\u2500 frontend/\n\u2502   \u2514\u2500\u2500 public-clients.yaml\n\u2502       realm: \"ecommerce\"\n\u2502       clients:\n\u2502         - clientId: \"web-shop\"\n\u2502         - clientId: \"mobile-app\"\n\u2502\n\u2514\u2500\u2500 hr/\n    \u2514\u2500\u2500 employees.yaml\n        realm: \"ecommerce\"\n        users:\n          - username: \"john.doe\"\n          - username: \"jane.smith\"\n</code></pre></p> <p>Import Process: <pre><code># Infrastructure team (rarely changes)\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations='config/infrastructure/*.yaml'\n\n# Backend team (updates service configs)\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations='config/backend/*.yaml'\n\n# Frontend team (updates client apps)\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations='config/frontend/*.yaml'\n\n# HR team (manages employees)\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations='config/hr/*.yaml'\n</code></pre></p> <p>Benefits: - Each team works independently - No conflicts between teams - Clear ownership - Easy to track changes in Git</p>"},{"location":"config/partial-imports/#advanced-selective-import-with-cache-keys","title":"Advanced: Selective Import with Cache Keys","text":"<p>Use cache keys to manage different sets of resources: <pre><code># Import and track clients separately\njava -jar keycloak-config-cli.jar \\\n  --import.cache.key=clients \\\n  --import.files.locations=clients.yaml\n\n# Import and track users separately\njava -jar keycloak-config-cli.jar \\\n  --import.cache.key=users \\\n  --import.files.locations=users.yaml\n</code></pre></p> <p>Benefits: - Independent checksum tracking - Can reimport one without affecting the other - Useful for scheduled imports of different components</p>"},{"location":"config/partial-imports/#troubleshooting","title":"Troubleshooting","text":""},{"location":"config/partial-imports/#resources-not-being-updated","title":"Resources Not Being Updated","text":"<p>Symptom: Changes in configuration file don't appear in Keycloak</p> <p>Possible causes: 1. Resource created manually (not managed by keycloak-config-cli) 2. Different cache key used 3. Remote state disabled</p> <p>Diagnosis: <pre><code># Check remote state\n--import.remote-state.enabled=true\n\n# Force reimport\n--import.cache.enabled=false\n</code></pre></p>"},{"location":"config/partial-imports/#resources-being-deleted-unexpectedly","title":"Resources Being Deleted Unexpectedly","text":"<p>Symptom: Resources disappear after import</p> <p>Possible causes: 1. Remote state disabled 2. Resource removed from config file that created it 3. Full realm export used instead of partial import</p> <p>Solution: - Always use <code>import.remote-state.enabled=true</code> - Only manage resources you intend to control - Keep resource definitions in their original files</p>"},{"location":"config/partial-imports/#import-order-matters","title":"Import Order Matters","text":"<p>Symptom: Import fails due to missing dependencies</p> <p>Cause: Trying to assign roles/groups that don't exist yet</p> <p>Solution: Import in dependency order: <pre><code># 1. Roles first\n--import.files.locations=roles.yaml\n\n# 2. Groups next\n--import.files.locations=groups.yaml\n\n# 3. Users last (can reference roles and groups)\n--import.files.locations=users.yaml\n</code></pre></p>"},{"location":"config/partial-imports/#consequences","title":"Consequences","text":"<p>When using partial imports:</p> <ol> <li>Independent Updates: Different teams can update their components without conflicts</li> <li>Reduced Risk: Only specified resources are affected by each import</li> <li>Modular Configuration: Easier to maintain small, focused files</li> <li>Requires Discipline: Teams must follow ownership conventions</li> <li>Remote State Essential: Partial imports require <code>import.remote-state.enabled=true</code></li> <li>Git-Friendly: Smaller files mean clearer Git diffs and easier reviews</li> </ol>"},{"location":"config/partial-imports/#migration-guide","title":"Migration Guide","text":""},{"location":"config/partial-imports/#from-full-realm-exports-to-partial-imports","title":"From Full Realm Exports to Partial Imports","text":"<p>Step 1: Export current realm <pre><code># Export full realm from Keycloak Admin Console\n# Realm Settings \u2192 Export \u2192 Export full realm\n</code></pre></p> <p>Step 2: Split into components <pre><code># Create separate files\nconfig/\n\u251c\u2500\u2500 clients.yaml       # Extract clients section\n\u251c\u2500\u2500 users.yaml         # Extract users section\n\u251c\u2500\u2500 roles.yaml         # Extract roles section\n\u2514\u2500\u2500 groups.yaml        # Extract groups section\n</code></pre></p> <p>Step 3: Clean up each file - Remove UUIDs - Remove default values - Keep only managed resources</p> <p>Step 4: Import incrementally <pre><code># Import one component at a time\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations=config/roles.yaml\n\n# Verify, then import next\njava -jar keycloak-config-cli.jar \\\n  --import.files.locations=config/clients.yaml\n</code></pre></p> <p>Step 5: Establish ownership - Document which team owns which file - Set up CI/CD pipelines per component - Train teams on their responsibilities</p>"},{"location":"config/partial-imports/#related-issues","title":"Related Issues","text":"<ul> <li>#1161 - Support Partial Imports into Keycloak</li> <li>#1237 - Working with Arrays</li> </ul>"},{"location":"config/partial-imports/#additional-resources","title":"Additional Resources","text":"<ul> <li>Managed Resources Documentation</li> <li>Import Settings Documentation</li> <li>Remote State Management</li> </ul>"},{"location":"config/remote-state-management/","title":"Remote State Management","text":"<p>Remote state management ensures that configurations are tracked and only modified when necessary, enabling safe and controlled updates to Keycloak configurations without altering unmanaged resources.</p> <p>Ensure your project directory has the following structure for sample demonstration locally:</p> <pre><code>keycloak-setup/\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 import.sh\n\u251c\u2500\u2500 keycloak-config-cli.jar\n\u2514\u2500\u2500 realms/\n\u2514\u2500\u2500 state-management.json\n</code></pre> <p>Each file serves the following purpose:</p> <ul> <li><code>docker-compose.yml</code>: Defines the Keycloak service.</li> <li><code>import.sh</code>: Custom shell script for running the Keycloak Config CLI against our Keycloak instance.</li> <li><code>keycloak-config-cli.jar</code>: Keycloak-config-cli is compatible with different versions of Keycloak and actively maintained.</li> <li><code>realms/state-management.json</code>: JSON file with realm configuration.</li> </ul> <p>In <code>docker-compose.yml</code>, configure the Keycloak service without a Keycloak Config CLI container, as we will be handling imports manually in this case.</p> <pre><code>services:\n  keycloak:\n    image: quay.io/keycloak/keycloak:25.0.1\n    environment:\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: admin\n      KC_HOSTNAME: localhost\n      KC_HTTP_PORT: \"8080\"\n      KC_HTTP_ENABLED: \"true\"\n      KC_METRICS_ENABLED: \"true\"\n      KC_HEALTH_ENABLED: \"true\"\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - ./realms:/opt/keycloak/data/import:z\n    command:\n      - \"start-dev\"\n</code></pre> <p>This file configures Keycloak with essential parameters and maps <code>./realms</code> for importing configuration files.</p> <p>The <code>import.sh</code> script uses the <code>keycloak-config-cli.jar</code> to apply configurations. This script will:</p> <ol> <li>Copy the config file to the container.</li> <li>Run the import using the CLI JAR file, with remote state management enabled.</li> </ol> <p>Create <code>import.sh</code> as follows:</p> <pre><code>#!/bin/bash\n\n# Check if a configuration file is provided\nif [ -z \"$1\" ]; then\n  echo \"Usage: ./import.sh &lt;config-file&gt;\"\n  exit 1\nfi\n\nCONFIG_FILE=$1\n\n# Run the Keycloak Config CLI tool with the updated options\njava -jar keycloak-config-cli.jar \\\n  --keycloak.url=\"http://localhost:8080\" \\\n  --keycloak.user=\"admin\" \\\n  --keycloak.password=\"admin\" \\\n  --import.managed.group=\"full\" \\\n  --import.remote-state.enabled=\"true\" \\\n  --import.files.locations=\"$CONFIG_FILE\"\n\necho \"Import of $CONFIG_FILE with remote-state enabled is complete.\"\n</code></pre> <p>Create <code>state-management.json</code> under <code>realms/</code>, which defines a Keycloak realm, clients, and roles.</p> <p>Define the realm, clients, roles, and scope mappings for demonstration:</p> <pre><code>{\n  \"realm\": \"master\",\n  \"enabled\": true,\n  \"clients\": [\n    {\n      \"clientId\": \"imported-client\",\n      \"enabled\": true,\n      \"protocol\": \"openid-connect\",\n      \"fullScopeAllowed\": false\n    }\n  ],\n  \"roles\": {\n    \"realm\": [\n      {\n        \"name\": \"my-role\",\n        \"description\": \"A test role\"\n      }\n    ]\n  },\n  \"clientScopes\": [\n    {\n      \"name\": \"custom-scope\",\n      \"description\": \"Custom client scope\",\n      \"protocol\": \"openid-connect\",\n      \"attributes\": {\n        \"include.in.token.scope\": \"true\"\n      }\n    }\n  ],\n  \"scopeMappings\": [\n    {\n      \"client\": \"imported-client\",\n      \"roles\": [\n        \"my-role\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"config/remote-state-management/#verifying-remote-state-management","title":"Verifying Remote State Management","text":"<p>With remote state management enabled, Keycloak Config CLI will only modify resources it initially created, preserving custom or manually added configurations.</p>"},{"location":"config/remote-state-management/#starting-keycloak","title":"Starting Keycloak","text":"<p>To start Keycloak, run:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"config/remote-state-management/#testing-remote-state","title":"Testing Remote State","text":"<p>Manually create a dedicated client to test remote state management.</p>"},{"location":"config/remote-state-management/#conclusion","title":"Conclusion","text":"<p>In this guide, we covered the basics of setting up Keycloak with Docker, creating an import script for configuration, and enabling remote state management using <code>keycloak-config-cli</code>.</p> <p>Feel free to reach out if you have any questions or need further assistance!</p>"},{"location":"config/user-profile-unmanaged-attributes/","title":"User Profile Unmanaged Attribute Policy","text":"<p>When configuring Keycloak user profiles, the <code>unmanagedAttributePolicy</code> setting controls how the system handles user attributes that aren't explicitly defined in the user profile configuration. Understanding how to properly configure this policy is essential for managing custom user attributes and controlling attribute permissions.</p> <p>Related issues: #1016</p>"},{"location":"config/user-profile-unmanaged-attributes/#the-problem","title":"The Problem","text":"<p>Users often encounter challenges when configuring user profile unmanaged attribute policies because: - Setting <code>unmanagedAttributePolicy</code> directly at the top level doesn't work as expected - The correct location for this setting within the user profile configuration is unclear - Different Keycloak versions have different user profile configuration structures - Error messages don't clearly indicate where the policy should be placed - The relationship between managed and unmanaged attributes is not well documented - Understanding the impact of different policy values requires trial and error</p>"},{"location":"config/user-profile-unmanaged-attributes/#what-is-unmanagedattributepolicy","title":"What is unmanagedAttributePolicy?","text":"<p>The <code>unmanagedAttributePolicy</code> determines how Keycloak handles user attributes that are NOT explicitly defined in the user profile configuration. These are attributes that users or administrators might add outside the defined profile schema.</p> <p>Policy Values:</p> Value Behavior Use Case <code>ENABLED</code> Unmanaged attributes can be created and edited by users Allow custom user attributes freely <code>ADMIN_EDIT</code> Only admins can create/edit unmanaged attributes Restrict attribute creation to admins <code>ADMIN_VIEW</code> Only admins can view unmanaged attributes; users cannot Hide custom attributes from users"},{"location":"config/user-profile-unmanaged-attributes/#correct-configuration-location","title":"Correct Configuration Location","text":""},{"location":"config/user-profile-unmanaged-attributes/#the-wrong-way-common-mistake","title":"The Wrong Way (Common Mistake)","text":"<p>This DOES NOT work: <pre><code>realm: \"myrealm\"\nuserProfile:\n  unmanagedAttributePolicy: \"ENABLED\"  # \u274c Wrong location!\n  attributes:\n    - name: \"username\"\n      required: true\n</code></pre></p> <p>Why it fails: The <code>unmanagedAttributePolicy</code> is not a direct child of <code>userProfile</code>. It must be nested within the profile configuration structure.</p>"},{"location":"config/user-profile-unmanaged-attributes/#the-correct-way","title":"The Correct Way","text":"<p>This WORKS: <pre><code>realm: \"myrealm\"\nuserProfile:\n  attributes:\n    - name: \"username\"\n      displayName: \"${username}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations: {}\n\n    - name: \"email\"\n      displayName: \"${email}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        email: {}\n\n    - name: \"firstName\"\n      displayName: \"${firstName}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n    - name: \"lastName\"\n      displayName: \"${lastName}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n  groups: []\n\n  unmanagedAttributePolicy: \"ENABLED\"  # \u2705 Correct location!\n</code></pre></p> <p>Key points: - <code>unmanagedAttributePolicy</code> is at the same level as <code>attributes</code> and <code>groups</code> - It's inside <code>userProfile</code> but not inside <code>attributes</code> - All managed attributes should be explicitly defined before setting the policy</p>"},{"location":"config/user-profile-unmanaged-attributes/#usage","title":"Usage","text":""},{"location":"config/user-profile-unmanaged-attributes/#allow-users-to-add-custom-attributes","title":"Allow Users to Add Custom Attributes","text":"<p>Scenario: You want users to be able to add their own custom attributes (like department, phone extension, etc.) <pre><code>realm: \"myrealm\"\nuserProfile:\n  attributes:\n    - name: \"username\"\n      displayName: \"${username}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n    - name: \"email\"\n      displayName: \"${email}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        email: {}\n\n  unmanagedAttributePolicy: \"ENABLED\"\n</code></pre></p> <p>Result: - Users can add custom attributes via API or account management - Users can view and edit their own custom attributes - Admins can also view and edit all attributes - Useful for flexible, self-service attribute management</p> <p>Example of user adding custom attribute: <pre><code>{\n  \"username\": \"john.doe\",\n  \"email\": \"john@example.com\",\n  \"attributes\": {\n    \"department\": [\"Engineering\"],\n    \"phone_extension\": [\"1234\"]\n  }\n}\n</code></pre></p>"},{"location":"config/user-profile-unmanaged-attributes/#restrict-unmanaged-attributes-to-admin-only-edit","title":"Restrict Unmanaged Attributes to Admin Only (Edit)","text":"<p>Scenario: Only administrators should be able to create and modify unmanaged attributes. <pre><code>realm: \"myrealm\"\nuserProfile:\n  attributes:\n    - name: \"username\"\n      displayName: \"${username}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n    - name: \"email\"\n      displayName: \"${email}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        email: {}\n\n    - name: \"firstName\"\n      displayName: \"${firstName}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n    - name: \"lastName\"\n      displayName: \"${lastName}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n  unmanagedAttributePolicy: \"ADMIN_EDIT\"\n</code></pre></p> <p>Result: - Users can view unmanaged attributes but cannot create or edit them - Only admins can create, view, and edit unmanaged attributes - Useful for controlled attribute management with admin oversight</p>"},{"location":"config/user-profile-unmanaged-attributes/#hide-unmanaged-attributes-from-users","title":"Hide Unmanaged Attributes from Users","text":"<p>Scenario: Unmanaged attributes should be completely hidden from regular users. <pre><code>realm: \"myrealm\"\nuserProfile:\n  attributes:\n    - name: \"username\"\n      displayName: \"${username}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n    - name: \"email\"\n      displayName: \"${email}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        email: {}\n\n  unmanagedAttributePolicy: \"ADMIN_VIEW\"\n</code></pre></p> <p>Result: - Users cannot view, create, or edit unmanaged attributes - Only admins can see and manage all attributes - Useful for storing sensitive or system-level attributes - Users only see attributes explicitly defined with user view permissions</p>"},{"location":"config/user-profile-unmanaged-attributes/#complete-user-profile-configuration-example","title":"Complete User Profile Configuration Example","text":"<p>Scenario: A corporate environment with defined attributes and controlled unmanaged attribute access. <pre><code>realm: \"corporate\"\nuserProfile:\n  attributes:\n    # Standard Keycloak attributes\n    - name: \"username\"\n      displayName: \"${username}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\"]  # Only admin can change username\n      validations:\n        length:\n          min: 3\n          max: 255\n        username-prohibited-characters: {}\n\n    - name: \"email\"\n      displayName: \"${email}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        email: {}\n        length:\n          max: 255\n\n    - name: \"firstName\"\n      displayName: \"${firstName}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        length:\n          max: 255\n        person-name-prohibited-characters: {}\n\n    - name: \"lastName\"\n      displayName: \"${lastName}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        length:\n          max: 255\n        person-name-prohibited-characters: {}\n\n    # Custom managed attributes\n    - name: \"department\"\n      displayName: \"Department\"\n      required: false\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\"]  # Only admin can set department\n      validations:\n        length:\n          max: 100\n\n    - name: \"employeeId\"\n      displayName: \"Employee ID\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\"]  # Only admin can set employee ID\n      validations:\n        length:\n          min: 5\n          max: 20\n\n    - name: \"phoneNumber\"\n      displayName: \"Phone Number\"\n      required: false\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        pattern:\n          pattern: \"^\\\\+?[1-9]\\\\d{1,14}$\"\n          error-message: \"Invalid phone number format\"\n\n  groups: []\n\n  unmanagedAttributePolicy: \"ADMIN_EDIT\"\n</code></pre></p> <p>This configuration: - Defines 6 managed attributes with clear permissions - Allows admins to add additional attributes as needed - Prevents users from adding arbitrary attributes - Enforces validation on all managed attributes - Provides clear separation between user-editable and admin-only fields</p>"},{"location":"config/user-profile-unmanaged-attributes/#attribute-types-managed-vs-unmanaged","title":"Attribute Types: Managed vs Unmanaged","text":""},{"location":"config/user-profile-unmanaged-attributes/#managed-attributes","title":"Managed Attributes","text":"<p>Definition: Explicitly defined in the <code>attributes</code> array with: - Name - Display name - Permissions - Validations - Required flag</p> <p>Example: <pre><code>attributes:\n  - name: \"department\"\n    displayName: \"Department\"\n    required: false\n    permissions:\n      view: [\"admin\", \"user\"]\n      edit: [\"admin\"]\n</code></pre></p> <p>Characteristics: - Full control over permissions - Validation rules enforced - Clear documentation in configuration - Consistent behavior across the realm</p>"},{"location":"config/user-profile-unmanaged-attributes/#unmanaged-attributes","title":"Unmanaged Attributes","text":"<p>Definition: Attributes NOT in the <code>attributes</code> array, added dynamically by users or systems.</p> <p>Examples: - <code>custom_field_1</code> - <code>legacy_system_id</code> - <code>temporary_flag</code></p> <p>Behavior: Controlled by <code>unmanagedAttributePolicy</code></p> <p>When to use: - Temporary attributes during migrations - Integration with external systems - User-defined custom fields - Attributes that vary per user type</p>"},{"location":"config/user-profile-unmanaged-attributes/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"config/user-profile-unmanaged-attributes/#1-wrong-configuration-level","title":"1. Wrong Configuration Level","text":"<p>Problem: <pre><code>realm: \"myrealm\"\nunmanagedAttributePolicy: \"ENABLED\"  # \u274c At realm level\nuserProfile:\n  attributes:\n    - name: \"username\"\n</code></pre></p> <p>Solution: <pre><code>realm: \"myrealm\"\nuserProfile:\n  attributes:\n    - name: \"username\"\n  unmanagedAttributePolicy: \"ENABLED\"  # \u2705 Inside userProfile\n</code></pre></p>"},{"location":"config/user-profile-unmanaged-attributes/#2-missing-required-attributes","title":"2. Missing Required Attributes","text":"<p>Problem: <pre><code>userProfile:\n  unmanagedAttributePolicy: \"ENABLED\"  # Missing standard attributes\n</code></pre></p> <p>Solution: Always include standard Keycloak attributes: <pre><code>userProfile:\n  attributes:\n    - name: \"username\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n    - name: \"email\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n  unmanagedAttributePolicy: \"ENABLED\"\n</code></pre></p>"},{"location":"config/user-profile-unmanaged-attributes/#3-incomplete-attribute-definitions","title":"3. Incomplete Attribute Definitions","text":"<p>Problem: <pre><code>attributes:\n  - name: \"department\"  # Missing permissions!\n</code></pre></p> <p>What happens: Attribute behavior is unpredictable.</p> <p>Solution: Always include complete attribute definitions: <pre><code>attributes:\n  - name: \"department\"\n    displayName: \"Department\"\n    required: false\n    permissions:\n      view: [\"admin\", \"user\"]\n      edit: [\"admin\"]\n    validations: {}\n</code></pre></p>"},{"location":"config/user-profile-unmanaged-attributes/#4-conflicting-policies-and-permissions","title":"4. Conflicting Policies and Permissions","text":"<p>Problem: <pre><code>userProfile:\n  attributes:\n    - name: \"customField\"\n      permissions:\n        edit: [\"user\"]  # Users can edit\n  unmanagedAttributePolicy: \"ADMIN_EDIT\"  # But unmanaged attributes are admin-only\n</code></pre></p> <p>Confusion: If <code>customField</code> is managed, users can edit it. But if it becomes unmanaged (removed from config), only admins can edit.</p> <p>Solution: Be consistent with your policy: - If allowing user attributes, use <code>ENABLED</code> - If restricting to admins, define all needed attributes as managed</p>"},{"location":"config/user-profile-unmanaged-attributes/#5-exporting-and-re-importing-user-profiles","title":"5. Exporting and Re-importing User Profiles","text":"<p>Problem: Exporting a realm and attempting to re-import the user profile without proper structure.</p> <p>Exported (may be incomplete): <pre><code>{\n  \"userProfile\": {\n    \"attributes\": [...]\n  }\n}\n</code></pre></p> <p>Solution: Ensure <code>unmanagedAttributePolicy</code> is included: <pre><code>userProfile:\n  attributes: [...]\n  groups: []\n  unmanagedAttributePolicy: \"ADMIN_EDIT\"\n</code></pre></p>"},{"location":"config/user-profile-unmanaged-attributes/#best-practices","title":"Best Practices","text":"<ol> <li>Always Define Core Attributes: Include username, email, firstName, lastName as managed attributes</li> <li>Use Managed Attributes for Important Fields: Define critical business attributes explicitly</li> <li>Choose Policy Based on Security: Use <code>ADMIN_EDIT</code> or <code>ADMIN_VIEW</code> for production environments</li> <li>Document Custom Attributes: Comment your configuration explaining custom fields</li> <li>Test Permission Changes: Verify users can/cannot edit attributes as expected</li> <li>Version Control User Profiles: Track changes to user profile configuration in Git</li> <li>Validate After Import: Check Admin Console to verify policy was applied correctly</li> <li>Consider Migration Impact: Changing policy affects existing unmanaged attributes</li> </ol>"},{"location":"config/user-profile-unmanaged-attributes/#validation-and-permissions-reference","title":"Validation and Permissions Reference","text":""},{"location":"config/user-profile-unmanaged-attributes/#permission-values","title":"Permission Values","text":"Permission Who Can Access <code>[\"admin\", \"user\"]</code> Both admins and users <code>[\"admin\"]</code> Only admins <code>[\"user\"]</code> Only users (rare, usually combined with admin)"},{"location":"config/user-profile-unmanaged-attributes/#common-validations","title":"Common Validations","text":"<pre><code>validations:\n  # Email format\n  email: {}\n\n  # String length\n  length:\n    min: 3\n    max: 255\n\n  # Pattern matching\n  pattern:\n    pattern: \"^[A-Z]{2}\\\\d{4}$\"\n    error-message: \"Must be 2 letters + 4 digits\"\n\n  # Username restrictions\n  username-prohibited-characters: {}\n\n  # Person name restrictions\n  person-name-prohibited-characters: {}\n</code></pre>"},{"location":"config/user-profile-unmanaged-attributes/#migration-scenarios","title":"Migration Scenarios","text":""},{"location":"config/user-profile-unmanaged-attributes/#from-no-user-profile-to-managed-profile","title":"From No User Profile to Managed Profile","text":"<p>Step 1: Export current user attributes <pre><code># Identify existing custom attributes in your realm\n# Check users via Admin Console or API\n</code></pre></p> <p>Step 2: Create user profile configuration <pre><code>realm: \"myrealm\"\nuserProfile:\n  attributes:\n    # Standard attributes\n    - name: \"username\"\n      displayName: \"${username}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n    - name: \"email\"\n      displayName: \"${email}\"\n      required: true\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n      validations:\n        email: {}\n\n    # Existing custom attributes (now managed)\n    - name: \"department\"\n      displayName: \"Department\"\n      required: false\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\"]\n\n    - name: \"employeeId\"\n      displayName: \"Employee ID\"\n      required: false\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\"]\n\n  unmanagedAttributePolicy: \"ADMIN_EDIT\"  # Lock down future attributes\n</code></pre></p> <p>Step 3: Import configuration <pre><code>java -jar keycloak-config-cli.jar \\\n  --keycloak.url=http://localhost:8080 \\\n  --keycloak.user=admin \\\n  --keycloak.password=admin \\\n  --import.files.locations=user-profile-config.yaml\n</code></pre></p> <p>Step 4: Verify in Admin Console - Navigate to: Realm Settings \u2192 User Profile - Check that all attributes are defined - Verify <code>unmanagedAttributePolicy</code> is set correctly</p>"},{"location":"config/user-profile-unmanaged-attributes/#changing-policy-from-enabled-to-admin_edit","title":"Changing Policy from ENABLED to ADMIN_EDIT","text":"<p>Scenario: You've allowed users to create custom attributes, now you want to lock it down.</p> <p>Current: <pre><code>userProfile:\n  attributes: [...]\n  unmanagedAttributePolicy: \"ENABLED\"\n</code></pre></p> <p>New: <pre><code>userProfile:\n  attributes:\n    # Add any commonly used unmanaged attributes as managed\n    - name: \"phoneExtension\"  # Was unmanaged, now managed\n      displayName: \"Phone Extension\"\n      required: false\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\", \"user\"]\n\n    - name: \"officeLocation\"  # Was unmanaged, now managed\n      displayName: \"Office Location\"\n      required: false\n      permissions:\n        view: [\"admin\", \"user\"]\n        edit: [\"admin\"]\n\n  unmanagedAttributePolicy: \"ADMIN_EDIT\"  # Changed\n</code></pre></p> <p>Impact: - Existing unmanaged attributes remain but become read-only for users - Users cannot create new unmanaged attributes - Any frequently used unmanaged attributes should be promoted to managed</p>"},{"location":"config/user-profile-unmanaged-attributes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"config/user-profile-unmanaged-attributes/#policy-not-applied","title":"Policy Not Applied","text":"<p>Symptom: Users can still edit unmanaged attributes despite <code>ADMIN_EDIT</code> setting</p> <p>Diagnosis: <pre><code># Check current user profile via API\ncurl -s \"http://localhost:8080/admin/realms/myrealm/users/profile\" \\\n  -H \"Authorization: Bearer $TOKEN\" | jq '.unmanagedAttributePolicy'\n</code></pre></p> <p>Possible causes: 1. Policy not at correct level in configuration 2. Configuration not imported successfully 3. Keycloak version doesn't support user profiles</p> <p>Solution: - Verify configuration structure - Check import logs for errors - Ensure Keycloak version 15+ (user profiles introduced in v15)</p>"},{"location":"config/user-profile-unmanaged-attributes/#attribute-permissions-not-working","title":"Attribute Permissions Not Working","text":"<p>Symptom: Users can edit attributes marked as admin-only</p> <p>Cause: Attribute is unmanaged and policy is <code>ENABLED</code></p> <p>Solution: Move attribute to managed attributes list: <pre><code>attributes:\n  - name: \"restrictedField\"\n    permissions:\n      view: [\"admin\", \"user\"]\n      edit: [\"admin\"]  # Now enforced\n</code></pre></p>"},{"location":"config/user-profile-unmanaged-attributes/#cannot-create-users-after-enabling-profile","title":"Cannot Create Users After Enabling Profile","text":"<p>Symptom: User creation fails after enabling user profile</p> <p>Cause: Required attributes not provided during user creation</p> <p>Solution: Ensure all <code>required: true</code> attributes are provided: <pre><code>{\n  \"username\": \"john.doe\",\n  \"email\": \"john@example.com\",\n  \"firstName\": \"John\",\n  \"lastName\": \"Doe\",\n  \"enabled\": true\n}\n</code></pre></p> <p>Or mark optional in profile: <pre><code>attributes:\n  - name: \"firstName\"\n    required: false  # Make optional\n</code></pre></p>"},{"location":"config/user-profile-unmanaged-attributes/#configuration-options","title":"Configuration Options","text":"<pre><code># Validate configuration before import\n--import.validate=true\n\n# Enable remote state management\n--import.remote-state.enabled=true\n</code></pre>"},{"location":"config/user-profile-unmanaged-attributes/#consequences","title":"Consequences","text":"<p>When configuring user profile unmanaged attribute policy:</p> <ol> <li>ENABLED Policy: Maximum flexibility but less control over data structure</li> <li>ADMIN_EDIT Policy: Balanced approach for most organizations</li> <li>ADMIN_VIEW Policy: Highest security but may hide useful information from users</li> <li>Managed Attributes Required: Standard attributes (username, email, etc.) must be explicitly defined</li> <li>Existing Attributes Unaffected: Changing policy doesn't remove existing unmanaged attributes</li> <li>Validation Only on Managed: Unmanaged attributes have no validation rules</li> </ol>"},{"location":"config/user-profile-unmanaged-attributes/#security-considerations","title":"Security Considerations","text":"<ol> <li>Least Privilege: Use <code>ADMIN_EDIT</code> or <code>ADMIN_VIEW</code> in production</li> <li>Sensitive Data: Store sensitive attributes as managed with admin-only permissions</li> <li>Data Leakage: <code>ENABLED</code> policy allows users to add arbitrary data</li> <li>Compliance: Some regulations require controlled attribute management</li> <li>Audit Trail: Managed attributes provide better audit capabilities</li> </ol>"},{"location":"config/user-profile-unmanaged-attributes/#keycloak-version-compatibility","title":"Keycloak Version Compatibility","text":"Keycloak Version User Profile Support unmanagedAttributePolicy &lt; 15.0.0 No N/A 15.0.0 - 18.0.0 Experimental Limited 19.0.0+ Stable Full support 21.0.0+ Enhanced Recommended <p>Note: For Keycloak versions before 15, user profile configuration is not available.</p>"}]}